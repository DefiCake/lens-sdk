## LENS V2 START

scalar EvmAddress

# ChainId custom scalar type
scalar ChainId

scalar ProfileId
scalar AppId
scalar Uri
scalar Erc20

scalar MetadataLicenseType
scalar ImageMimeType
scalar MetadataMediaAudioType
scalar ThreeDFormat
scalar AudioMimeType
scalar ImageSizeTransform
scalar VideoMimeType
scalar CreateDeleteEIP712TypedData
scalar ProfileSortCriteria
scalar CollectModuleData
scalar ReferenceModuleData
scalar FollowModuleData
scalar MomokaTransactionUnion

type NetworkAddress {
  address: EvmAddress!
  chainId: ChainId!
}

# The NFT image
type NftImage {
  # The contract address
  collection: NetworkAddress!

  # The token id of the nft
  tokenId: String!

  # The token image nft
  image: ImageSet!

  # If the NFT is verified
  verified: Boolean!
}

union ProfilePicture = ImageSet | NftImage

type ProfileMetadata {
  # The raw OG metadata resolver link
  rawURL: Url

  # Name of the profile
  displayName: String

  # Bio of the profile
  bio: String

  # The cover picture for the profile
  coverPicture: ImageSet
}

type Handle {
  """
  Includes the network suffix (e.g. `.lens`)
  """
  name: String!
  contract: NetworkAddress!
  tokenId: TokenId!
}

# The gasless sponsor
type Gasless {
  enabled: Boolean!
  # The gasless relay sponsor address
  relay: NetworkAddress
}

# The open action module types
enum OpenActionModules {
  LegacyLimitedFeeCollectModule
  LegacyFeeCollectModule
  LegacyLimitedTimedFeeCollectModule
  LegacyTimedFeeCollectModule
  LegacyAaveFeeCollectModule
  LegacyRevertCollectModule
  LegacyFreeCollectModule
  LegacyMultirecipientFeeCollectModule
  LegacyERC4626FeeCollectModule
  LegacySimpleCollectModule
  LegacyUnknownCollectModule
  MultirecipientCollectOpenActionModule
  SimpleCollectOpenAction
  UnknownOpenActionModule
  NftDropOpenActionModule ## TODO! write doc
}

enum OpenActionCategories {
  Collect
}

input OpenActionFilter {
  address: EvmAddress
  type: OpenActionModules
  category: OpenActionCategories
}

# The Profile Stats
type ProfileStats {
  # Total follower count
  followers: Int!

  # Total following count (remember the wallet follows not profile so will be same for every profile they own)
  following: Int!

  comments: Int!

  posts: Int!

  mirrors: Int!

  publications: Int!

  reactions(type: ReactionTypes): Int!

  countOpenActions(anyOf: [OpenActionFilter!]): Int!
}

# The follow module types
enum FollowModules {
  FeeFollowModule
  RevertFollowModule
  ProfileFollowModule
  UnknownFollowModule
}

union FollowModule =
    FeeFollowModuleSettings
  | ProfileFollowModuleSettings
  | RevertFollowModuleSettings
  | UnknownFollowModuleSettings

type FeeFollowModuleSettings {
  contract: NetworkAddress!

  # The fee follow amount
  amount: Amount!

  # The recipient address
  recipient: EvmAddress!
}

type FiatAmount {
  asset: Fiat!

  value: String!
}

enum SupportedFiatTypes {
  USD
}

type Amount {
  # The ERC20 token info
  asset: ERC20!

  # Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal.
  value: String!

  # Fiat on the fly field resolver
  rate(currency: SupportedFiatTypes!): FiatAmount
}

# The ERC20 type
type ERC20 {
  # Name of the symbol
  name: String!

  # Symbol for the token
  symbol: String!

  # Decimal places for the token
  decimals: Int!

  # The ERC20 address
  contract: NetworkAddress!
}

type Fiat {
  # Name of the symbol
  name: String!

  # Symbol for the token
  symbol: String!

  # Decimal places for the token
  decimals: Int!
}

union Asset = ERC20 | Fiat

type ProfileFollowModuleSettings {
  contract: NetworkAddress!
}

type RevertFollowModuleSettings {
  contract: NetworkAddress!
}

type UnknownFollowModuleSettings {
  contract: NetworkAddress!

  # The data used to setup the module which you can decode with your known ABI
  followModuleReturnData: BlockchainData!
}

enum AttributeTypes {
  Boolean
  Date
  Number
  String
  JSON
}

type Attribute {
  type: AttributeTypes

  # identifier of this attribute, we will update by this id
  key: String!

  # Value attribute
  value: String!
}

type OnChainIdentity {
  # The POH status
  proofOfHumanity: ProofOfHumanity!

  # The ens information
  ens: EnsOnChainIdentity

  # The sybil dot org information
  sybilDotOrg: SybilDotOrgIdentity

  # The worldcoin identity
  worldcoin: WorldcoinIdentity!
}

# Ens custom scalar type
scalar Ens

type EnsOnChainIdentity {
  # The default ens mapped to this address
  name: Ens!
}

type ProofOfHumanity {
  isVerified: Boolean!
}

type SybilDotOrgIdentity {
  source: SybilDotOrgIdentitySource!
}

type SybilDotOrgIdentitySource {
  twitter: SybilDotOrgTwitterIdentity!
}

type SybilDotOrgTwitterIdentity {
  handle: String
}

type WorldcoinIdentity {
  # If the profile has verified as a user
  isHuman: Boolean!
  type: WorldcoinPhoneVerifyType
}

type OptimisticStatusResult {
  value: Boolean!
  isFinalisedOnChain: Boolean
}

type ProfileGuardianResult {
  protected: Boolean!
  cooldownEndsOn: DateTime
}

# The Profile
type Profile {
  # The profile id
  id: ProfileId!

  # The profile metadata
  metadata: ProfileMetadata

  # The profile handle
  handle: Handle

  # The picture for the profile
  picture: ProfilePicture

  # Who owns the profile
  ownedBy: NetworkAddress!

  gasless: Gasless!

  # Profile stats
  stats(forApps: [AppId!] = [], customFilters: [CustomFiltersTypes!] = []): ProfileStats!

  # The follow module
  followModule: FollowModule

  followNftAddress: NetworkAddress

  # Optionals param to add extra attributes on the metadata
  attributes: [Attribute!]!

  # The on chain identity
  onChainIdentity: OnChainIdentity!

  # The profile interests
  interests: [ProfileInterest!]!

  isFollowedByMe: OptimisticStatusResult!

  isFollowingMe: OptimisticStatusResult!

  guardian: ProfileGuardianResult!

  invitedBy: Profile

  invitesLeft: Int!

  createdAt: DateTime!
}

## END OF PROFILE

## PUBLICATION

type App {
  id: AppId!
}

union AnyPublication = Post | Comment | Mirror | Quote

scalar MomokaProof

type MomokaInfo {
  proof: MomokaProof!
}

type OpenActionActed {
  address: EvmAddress
  type: OpenActionModules
  isFinalisedOnChain: Boolean
}

enum CollectOpenActionModules {
  LegacyLimitedFeeCollectModule
  LegacyFeeCollectModule
  LegacyLimitedTimedFeeCollectModule
  LegacyTimedFeeCollectModule
  LegacyAaveFeeCollectModule
  LegacyRevertCollectModule
  LegacyFreeCollectModule
  LegacyMultirecipientFeeCollectModule
  LegacyERC4626FeeCollectModule
  LegacySimpleCollectModule
  LegacyUnknownCollectModule
  MultirecipientCollectOpenActionModule
  SimpleCollectOpenAction
}

type CollectOpenActionResult {
  type: CollectOpenActionModules
}

type NftDropOpenAction {
  ## TODO! INSERT FILEDS
  tokenMinted: Int
}

type UnknownOpenActionResult {
  address: EvmAddress
  redeemData: BlockchainData
}

union OpenActionResult = CollectOpenActionResult | NftDropOpenAction | UnknownOpenActionResult

type CanDecryptResponse {
  result: Boolean!
  reasons: [DecryptFailReasonTypes!]
  extraDetails: String
}

type PublicationOperations {
  hasReacted(type: ReactionTypes!): Boolean!

  isNotInterested: Boolean!

  hasBookmarked: Boolean!

  hasActed: [OpenActionResult!]!

  canComment: Boolean!

  canMirror: Boolean!

  hasMirrored: Boolean!

  canDecrypt: CanDecryptResponse
}

# The social post
type Post {
  # The publication id
  id: PublicationId!

  # The profile ref
  by: Profile!

  # The publication stats
  stats(forApps: [AppId!] = [], customFilters: [CustomFiltersTypes!] = []): PublicationStats!

  # The metadata for the post
  metadata: PublicationMetadata!

  # The open action module
  openActionModules: [OpenActionModule!]!

  # The reference module
  referenceModule: ReferenceModule

  # ID of the source
  publishedOn: App

  # If the publication has been hidden if it has then the content and media is not available
  isHidden: Boolean!

  # Indicates if the publication is gated behind some access criteria
  isGated: Boolean!

  # Indicates if the publication is data availability post
  momoka: MomokaInfo

  operations(by: ProfileId): PublicationOperations

  # The date the post was created on
  createdAt: DateTime!
}

# The publication stats
type PublicationStats {
  id: PublicationId!

  # The total amount of mirrors
  mirrors: Int!

  # The total amount of comments
  comments: Int!

  # The total amount of bookmarks
  bookmarks: Int!

  reactions(type: ReactionTypes): Int!

  countOpenActions(anyOf: [OpenActionFilter!]): Int!
}

# The custom filters types
enum CustomFiltersTypes {
  GARDENERS
}

# The publication metadata display types
enum MarketplaceMetadataAttributeDisplayTypes {
  number
  string
  date
}

# The metadata attribute output
type MarketplaceMetadataAttribute {
  # The display type
  displayType: MarketplaceMetadataAttributeDisplayTypes

  # The trait type - can be anything its the name it will render so include spaces
  traitType: String

  # The value
  value: String
}

type MarketplaceMetadata {
  description: Markdown

  externalUrl: Url

  name: String!

  attributes: [MarketplaceMetadataAttribute!]!

  image: Url

  animationUrl: Url

  # TODO LOOK AT NEW FIELDS!
  # https://docs.opensea.io/docs/metadata-standards
}

enum MetadataContentWarnings {
  NSFW
  SENSITIVE
  SPOILER
}

enum MetadataMainFocus {
  VIDEO
  IMAGE
  ARTICLE
  TEXT_ONLY
  AUDIO
  LINK
  EMBED
  CHECKING_IN
  EVENT
  MINT
  TRANSACTION
  LIVESTREAM
  SHORT_VIDEO
  THREE_D
  STORY
  SPACES
}

enum VideoMetadataV1MainFocus {
  VIDEO
  SHORT_VIDEO
}

enum ImageMetadataV1MainFocus {
  IMAGE
}

enum AudioMetadataV1MainFocus {
  AUDIO
}

enum ArticleMetadataV1MainFocus {
  ARTICLE
}

enum TextOnlyMetadataV1MainFocus {
  TEXT_ONLY
}

enum LinkMetadataV1MainFocus {
  LINK
}

enum EmbedMetadataV1MainFocus {
  EMBED
}

enum CheckingInMetadataV1MainFocus {
  CHECKING_IN
}

enum EventMetadataV1MainFocus {
  EVENT
}

enum TransactionMetadataV1MainFocus {
  TRANSACTION
}

enum MintMetadataV1MainFocus {
  MINT
}

enum SpaceMetadataV1MainFocus {
  SPACE
}

enum LiveStreamMetadataV1MainFocus {
  LIVESTREAM
}

interface MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  marketplace: MarketplaceMetadata

  encryptedWith: EncryptionStrategy
}

union MetadataAttachment = MetadataMediaVideo | MetadataMediaImage | MetadataMediaAudio

type MetadataMediaVideo {
  # TO CREATE VideoMimeType
  type: VideoMimeType!

  item: VideoSet

  cover: ImageSet

  duration: Int

  # TO CREATE MetadataLicenseType
  license: MetadataLicenseType
}

type MetadataMediaImage {
  # TO CREATE VideoMimeType
  type: ImageMimeType!

  item: ImageSet!

  # TO CREATE MetadataLicenseType
  license: MetadataLicenseType
}

type MetadataMediaAudio {
  type: AudioMimeType!
  item: AudioSet
  cover: ImageSet
  duration: Int
  license: MetadataLicenseType
  credits: String
  artist: String
  genre: String
  recordLabel: String
  audioType: MetadataMediaAudioType! ## TODO create
  lyrics: Url
}

type FutureProofMetadata {
  id: String
}

type VideoMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  video: MetadataMediaVideo!

  marketplace: MarketplaceMetadata

  mainContentFocus: VideoMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy
}

type ImageMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  marketplace: MarketplaceMetadata

  mainContentFocus: ImageMetadataV1MainFocus!

  image: MetadataMediaImage!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy
}

type ArticleMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown!

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  marketplace: MarketplaceMetadata

  mainContentFocus: ArticleMetadataV1MainFocus!

  title: String

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy
}

type AudioMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  audio: MetadataMediaAudio!

  marketplace: MarketplaceMetadata

  mainContentFocus: AudioMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy
}

type GeoLocation {
  latitude: Float!
  longitude: Float!
}

type EventMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  marketplace: MarketplaceMetadata

  mainContentFocus: EventMetadataV1MainFocus!

  geographic: GeoLocation

  startsAt: DateTime!

  endsAt: DateTime

  links: [Url!]

  location: Location!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy
}

type LinkMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  sharingLink: Uri!

  mainContentFocus: LinkMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy

  marketplace: MarketplaceMetadata
}

type EmbedMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  # TODO: Review if we can preprocess the uri
  embed: Uri!

  mainContentFocus: EmbedMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy

  marketplace: MarketplaceMetadata
}

scalar Location

type CheckingInMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  # TODO: Review LIP to allow Url to be inside location as with `Event`
  location: Location!

  geographic: GeoLocation

  mainContentFocus: CheckingInMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy

  marketplace: MarketplaceMetadata
}

type TextOnlyMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown!

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  marketplace: MarketplaceMetadata

  mainContentFocus: TextOnlyMetadataV1MainFocus!

  encryptedWith: EncryptionStrategy
}

enum ThreeDMetadataV1MainFocus {
  THREE_D
}

type ThreeDMetadataV1Asset {
  url: Url!
  zipPath: String
  playerUrl: String!
  format: ThreeDFormat!
  license: MetadataLicenseType
}

type ThreeDMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  # TODO! RENAME IN METADATA
  assets: [ThreeDMetadataV1Asset!]!

  mainContentFocus: ThreeDMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  marketplace: MarketplaceMetadata

  encryptedWith: EncryptionStrategy
}

enum StoryMetadataV1MainFocus {
  STORY
}

type StoryMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  mainContentFocus: StoryMetadataV1MainFocus!

  # TODO! REVIEW! ONLY 1
  asset: MetadataAttachment

  marketplace: MarketplaceMetadata

  encryptedWith: EncryptionStrategy
}

enum TransactionMetadataTypes {
  ERC721
  ERC20
  OTHER
}

type TransactionMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  type: TransactionMetadataTypes!

  txHash: String!

  chainId: ChainId!

  marketplace: MarketplaceMetadata

  mainContentFocus: TransactionMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy
}

# TODO WIP awaiting feedback from LIP
type MintMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  mintLink: Url!

  marketplace: MarketplaceMetadata

  mainContentFocus: MintMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy
}

type SpaceMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  title: String

  link: Url!

  # TODO! change in metadata spec
  startsAt: DateTime!

  marketplace: MarketplaceMetadata

  mainContentFocus: SpaceMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy
}

type LiveStreamMetadataV1 implements MetadataV3Common {
  id: String!

  rawURL: Url!

  content: Markdown

  locale: Locale!

  tags: [String!]

  contentWarning: PublicationContentWarning

  hideFromFeed: Boolean!

  globalReach: Boolean!

  appId: AppId

  title: String

  startsAt: DateTime!

  endsAt: DateTime

  playbackUrl: Url!

  liveUrl: Url!

  isLiveNowApiCall: Url

  marketplace: MarketplaceMetadata

  mainContentFocus: LiveStreamMetadataV1MainFocus!

  attachments: [MetadataAttachment!]

  encryptedWith: EncryptionStrategy
}

union MetadataV3 =
    VideoMetadataV1
  | ImageMetadataV1
  | ArticleMetadataV1
  | EventMetadataV1
  | LinkMetadataV1
  | EmbedMetadataV1
  | CheckingInMetadataV1
  | TextOnlyMetadataV1
  | ThreeDMetadataV1
  | StoryMetadataV1
  | TransactionMetadataV1
  | MintMetadataV1
  | SpaceMetadataV1
  | LiveStreamMetadataV1
  | FutureProofMetadata

union PublicationMetadata =
    MetadataV2
  | VideoMetadataV1
  | ImageMetadataV1
  | ArticleMetadataV1
  | EventMetadataV1
  | LinkMetadataV1
  | EmbedMetadataV1
  | CheckingInMetadataV1
  | TextOnlyMetadataV1
  | ThreeDMetadataV1
  | StoryMetadataV1
  | TransactionMetadataV1
  | MintMetadataV1
  | SpaceMetadataV1
  | LiveStreamMetadataV1
  | FutureProofMetadata

input ImageTransform {
  # Set the transformed image's width. You can use specific size in pixels eg. 100px, a percentage eg. 50% or set as 'auto' to be set automatically. Default value is 'auto'.
  width: ImageSizeTransform = "auto"

  # Set the transformed image's height. You can use specific size in pixels eg. 100px, a percentage eg. 50% or set as 'auto' to be set automatically. Default value is 'auto'.
  height: ImageSizeTransform = "auto"

  # Set if you want to keep the image's original aspect ratio. True by default. If explicitly set to false, the image will stretch based on the width and height values.
  keepAspectRatio: Boolean = true
}

# mimetype custom scalar type
scalar MimeType

type Video {
  url: Url!
  # TODO! lets create an enum for this VideoMimeType
  mimeType: VideoMimeType
}

type VideoSet {
  rawURL: Url!
  media: Video!
  altTag: String
}

type Audio {
  url: Url!
  # TODO! lets create an enum for this AudioMimeType
  mimeType: AudioMimeType
}

type AudioSet {
  rawURL: Url!
  media: Audio!
}

type Image {
  url: Url!
  mimeType: MimeType

  # optional if not snapshotted
  width: Int
  # optional if not snapshotted
  height: Int
}

type ImageSet {
  rawURL: Url!
  media: Image!
  altTag: String
  transformed(input: ImageTransform): Image
}

union MediaSet = VideoSet | AudioSet | ImageSet

# The publication main focus
enum MetadataV2MainFocus {
  VIDEO
  IMAGE
  ARTICLE
  TEXT_ONLY
  AUDIO
  LINK
  EMBED
}

# Markdown scalar type
scalar Markdown

# Locale scalar type
scalar Locale

# The metadata output
type MetadataV2 {
  # The metadata name
  name: String

  # This is the metadata description
  description: Markdown

  # This is the metadata content for the publication, should be markdown
  content: Markdown

  # This is the image attached to the metadata and the property used to show the NFT!
  image: ImageSet

  # The images/audios/videos for the publication
  media: [MediaSet!]!

  # The attributes
  attributes: [MarketplaceMetadataAttribute!]

  # The locale of the publication,
  locale: Locale!

  # The tags for the publication
  tags: [String!]

  # The content warning for the publication
  contentWarning: PublicationContentWarning

  # The main focus of the publication
  mainContentFocus: MetadataV2MainFocus!

  # The main focus of the publication
  animationUrl: Url

  # The publication's encryption params in case it's encrypted
  encryptionInput: MetadataV2Encryption
}

# The publication content warning
enum PublicationContentWarning {
  NSFW
  SENSITIVE
  SPOILER
}

# ContentEncryptionKey scalar type
scalar ContentEncryptionKey

# The metadata encryption params
type MetadataV2Encryption {
  # The provider-specific encryption params
  encryptionKey: ContentEncryptionKey!

  # The access conditions
  accessCondition: AccessCondition!

  # The encrypted fields
  encryptedFields: MetadataV2EncryptedFields!
}

# The metadata encryption params
type MetadataV3LitEncryption {
  # The provider-specific encryption params
  encryptionKey: ContentEncryptionKey!

  # The access conditions
  accessCondition: AccessCondition!
}

type FutureProofEncryptionStrategy {
  id: String
}

union EncryptionStrategy = MetadataV3LitEncryption | FutureProofEncryptionStrategy

union AccessCondition =
    NftOwnershipCondition
  | Erc20OwnershipCondition
  | EoaOwnershipCondition
  | ProfileOwnershipCondition
  | FollowCondition
  | CollectCondition
  | AndCondition
  | OrCondition

# The gated publication access criteria contract types
enum NftContractType {
  ERC721
  ERC1155
}

# The NFT token id
scalar NftTokenId

type NftOwnershipCondition {
  # The NFT collection's ethereum address
  contract: NetworkAddress!

  # The unlocker contract type
  contractType: NftContractType!

  # The optional token ID(s) to check for ownership
  tokenIds: [NftTokenId!]
}

type Erc20OwnershipCondition {
  # The ERC20 token ethereum address
  contract: NetworkAddress!

  amount: Amount!

  # The operator to use when comparing the amount of tokens
  condition: ScalarOperator!
}

# The gated publication access criteria scalar operators
enum ScalarOperator {
  EQUAL
  NOT_EQUAL
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN
  LESS_THAN_OR_EQUAL
}

type EoaOwnershipCondition {
  # The address that will have access to the content
  address: EvmAddress!
}

# Condition that signifies if address has access to profile
type ProfileOwnershipCondition {
  # The profile id
  profileId: ProfileId!
}

type FollowCondition {
  # The profile id of the gated profile
  profileId: ProfileId!
}

# Condition that signifies if address or profile has collected a publication
type CollectCondition {
  # The publication id that has to be collected to unlock content
  publicationId: PublicationId

  # True if the content will be unlocked for this specific publication
  thisPublication: Boolean
}

type AndCondition {
  # The list of conditions to apply AND to. You can only use nested boolean conditions at the root level.
  criteria: [AccessCondition!]!
}

type OrCondition {
  # The list of conditions to apply OR to. You can only use nested boolean conditions at the root level.
  criteria: [AccessCondition!]!
}

# EncryptedValue custom scalar type
scalar EncryptedValueScalar

# The encrypted fields
type MetadataV2EncryptedFields {
  # The encrypted content field
  content: EncryptedValueScalar

  # The encrypted image field
  image: EncryptedValueScalar

  # The encrypted media field
  media: [EncryptedMedia!]

  # The encrypted animation_url field
  animationUrl: EncryptedValueScalar

  # The encrypted external_url field
  externalUrl: EncryptedValueScalar
}

# The Encrypted Media url and metadata
type EncryptedMedia {
  # The encrypted value for the URL
  url: Url!

  # The image/audio/video mime type for the publication
  mimeType: MimeType

  # The encrypted alt tags for accessibility
  altTag: EncryptedValueScalar

  # The encrypted cover for any video or audio you attached
  cover: EncryptedValueScalar
}

union LegacyCollectModuleSettings =
    LegacyFreeCollectModuleSettings
  | LegacyFeeCollectModuleSettings
  | LegacyLimitedFeeCollectModuleSettings
  | LegacyLimitedTimedFeeCollectModuleSettings
  | LegacyRevertCollectModuleSettings
  | LegacyTimedFeeCollectModuleSettings
  | LegacyMultirecipientFeeCollectModuleSettings
  | LegacySimpleCollectModuleSettings
  | LegacyERC4626FeeCollectModuleSettings
  | LegacyAaveFeeCollectModuleSettings

union OpenActionModule =
    LegacyFreeCollectModuleSettings
  | LegacyFeeCollectModuleSettings
  | LegacyLimitedFeeCollectModuleSettings
  | LegacyLimitedTimedFeeCollectModuleSettings
  | LegacyRevertCollectModuleSettings
  | LegacyTimedFeeCollectModuleSettings
  | LegacyMultirecipientFeeCollectModuleSettings
  | LegacySimpleCollectModuleSettings
  | LegacyERC4626FeeCollectModuleSettings
  | LegacyAaveFeeCollectModuleSettings
  | MultirecipientFeeCollectOpenActionSettings
  | SimpleCollectOpenActionSettings
  | UnknownOpenActionSettings
#| ERC4626FeeOpenActionSettings # will be in v2?
#| AaveFeeOpenActionSettings # will be in v2?

type SimpleCollectOpenActionSettings {
  contract: NetworkAddress!

  # The fee amount
  amount: Amount!

  # The fee recipient
  recipient: EvmAddress!

  # The referral fee
  referralFee: Float!

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endsAt: DateTime
}

type MultirecipientFeeCollectOpenActionSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # The referral fee associated with this publication.
  referralFee: Float!

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endsAt: DateTime

  # Recipient of collect fees.
  recipients: [RecipientDataOutput!]!
}

type LegacyFreeCollectModuleSettings {
  contract: NetworkAddress!

  # Follower only
  followerOnly: Boolean!
}

type LegacyFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # Follower only
  followerOnly: Boolean!
}

type LegacyLimitedFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module limit
  collectLimit: String!

  # The collect module amount info
  amount: Amount!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # Follower only
  followerOnly: Boolean!
}

type LegacyLimitedTimedFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module limit
  collectLimit: String!

  # The collect module amount info
  amount: Amount!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # Follower only
  followerOnly: Boolean!

  # The collect module end timestamp
  endsAt: DateTime!
}

type LegacyRevertCollectModuleSettings {
  contract: NetworkAddress!
}

type LegacyTimedFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # Follower only
  followerOnly: Boolean!

  # The collect module end timestamp
  endsAt: DateTime!
}

type LegacyMultirecipientFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # The referral fee associated with this publication.
  referralFee: Float!

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endsAt: DateTime

  # Recipient of collect fees.
  recipients: [RecipientDataOutput!]!
}

type RecipientDataOutput {
  # Recipient of collect fees.
  recipient: EvmAddress!

  # Split %, should be between 0.01 and 100. Up to 2 decimal points supported. All % should add up to 100
  split: Float!
}

type LegacySimpleCollectModuleSettings {
  contract: NetworkAddress!

  # The fee amount
  amount: Amount!

  # The fee recipient
  recipient: EvmAddress!

  # The referral fee
  referralFee: Float!

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endsAt: DateTime
}

type LegacyERC4626FeeCollectModuleSettings {
  contract: NetworkAddress!

  # The ERC4626 vault address
  vault: EvmAddress!

  # The collect module amount info
  amount: Amount!

  # The recipient of the ERC4626 vault shares
  recipient: EvmAddress!

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # The referral fee associated with this publication.
  referralFee: Float!

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endsAt: DateTime
}

type LegacyAaveFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The maximum number of collects for this publication. Omit for no limit.
  collectLimit: String

  # The referral fee associated with this publication.
  referralFee: Float!

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. No expiry if missing.
  endsAt: DateTime

  # Recipient of collect fees.
  recipient: EvmAddress!
}

type UnknownCollectModuleSettings {
  contract: NetworkAddress!

  # The data used to setup the module which you can decode with your known ABI
  collectModuleReturnData: BlockchainData!
}

type UnknownOpenActionSettings {
  contract: NetworkAddress!

  # The data used to setup the module which you can decode with your known ABI
  openActionModuleReturnData: BlockchainData!
}

union ReferenceModule =
    FollowOnlyReferenceModuleSettings
  | DegreesOfSeparationReferenceModuleSettings
  | UnknownReferenceModuleSettings

type FollowOnlyReferenceModuleSettings {
  contract: NetworkAddress!
}

# The reference module types
enum ReferenceModules {
  FollowerOnlyReferenceModule
  DegreesOfSeparationReferenceModule
  UnknownReferenceModule
}

type UnknownReferenceModuleSettings {
  contract: NetworkAddress!

  # The data used to setup the module which you can decode with your known ABI
  referenceModuleReturnData: BlockchainData!
}

type DegreesOfSeparationReferenceModuleSettings {
  contract: NetworkAddress!

  # Applied to comments
  commentsRestricted: Boolean!

  # Applied to mirrors
  mirrorsRestricted: Boolean!

  # Degrees of separation
  degreesOfSeparation: Int!
}

# Reaction types
enum ReactionTypes {
  UPVOTE
  DOWNVOTE
}

# The reason why a profile cannot decrypt a publication
enum DecryptFailReasonTypes {
  UNAUTHORIZED_ADDRESS
  DOES_NOT_OWN_NFT
  DOES_NOT_OWN_PROFILE
  DOES_NOT_FOLLOW_PROFILE
  HAS_NOT_COLLECTED_PUBLICATION
  UNAUTHORIZED_BALANCE
  PROFILE_DOES_NOT_EXIST
  MISSING_ENCRYPTION_PARAMS
  FOLLOW_NOT_FINALISED_ON_CHAIN
  COLLECT_NOT_FINALISED_ON_CHAIN
  CAN_NOT_DECRYPT
}

# The social comment
type Comment {
  # The publication id
  id: PublicationId!

  # The profile ref
  by: Profile!

  # The publication stats
  stats(forApps: [AppId!] = [], customFilters: [CustomFiltersTypes!] = []): PublicationStats!

  # The metadata for the post
  metadata: PublicationMetadata!

  # The collect module
  openActionModules: [OpenActionModule!]!

  # The reference module
  referenceModule: ReferenceModule

  # ID of the source
  publishedOn: App

  # If the publication has been hidden if it has then the content and media is not available
  isHidden: Boolean!

  # Indicates if the publication is gated behind some access criteria
  isGated: Boolean!

  # Indicates if the publication is data availability post
  momoka: MomokaInfo

  # The top level post this comment lives on
  root: Post!

  # Which comment this points to if its null the pointer too deep so do another query to find it out
  commentOn: PrimaryPublication

  # This will bring back the first comment of a comment and only be defined if using `publication` query and `commentOf`
  firstComment: Comment

  operations(by: ProfileId): PublicationOperations

  # The date the post was created on
  createdAt: DateTime!
}

union PrimaryPublication = Post | Comment | Quote

union MirrorablePublication = Post | Comment | Quote

# The social mirror
type Mirror {
  # The publication id
  id: PublicationId!

  # The profile ref
  by: Profile!

  # Indicates if the publication is data availability post
  momoka: MomokaInfo

  # The mirror publication
  mirrorOf: MirrorablePublication!

  # The date the post was created on
  createdAt: DateTime!
}

type Quote {
  # The publication id
  id: PublicationId!

  # The profile ref
  by: Profile!

  # The publication stats
  stats(forApps: [AppId!] = [], customFilters: [CustomFiltersTypes!] = []): PublicationStats!

  # The metadata for the post
  metadata: PublicationMetadata!

  # The collect module
  openActionModules: [OpenActionModule!]!

  # The reference module
  referenceModule: ReferenceModule

  # ID of the source
  publishedOn: App

  # If the publication has been hidden if it has then the content and media is not available
  isHidden: Boolean!

  # Indicates if the publication is gated behind some access criteria
  isGated: Boolean!

  # Indicates if the publication is data availability post
  momoka: MomokaInfo

  # Which comment this points to if its null the pointer too deep so do another query to find it out
  quotedOn: PrimaryPublication

  operations(by: ProfileId): PublicationOperations

  # The date the post was created on
  createdAt: DateTime!
}

## PUBLICATION ENDS

## QUERY STARTS

input AlreadyInvitedCheckRequest {
  address: EvmAddress!
}

# Ethereum address custom scalar type
scalar EvmAddress

type InvitedResult {
  invited: EvmAddress!
  profileMinted: Profile
  when: DateTime
}

# The javascript `Date` as string. Type represents date and time as the ISO Date string.
scalar DateTime

# Represents NULL values
scalar Void

input RelRequest {
  secret: String!
  ethereumAddress: EvmAddress!
}

input CurRequest {
  secret: String!
}

# Url scalar type
scalar Url

input GdmRequest {
  secret: String!
}

input GctRequest {
  secret: String!
  hhh: String!
}

type PrfResponse {
  ss: Boolean!
  dd: Boolean!
}

input PriRequest {
  secret: String!
  hhh: String!
}

input InTotalRequest {
  secret: String!
  ethereumAddress: EvmAddress!
}

# jwt custom scalar type
scalar Jwt

# The tx hash
scalar TxHash

# The tx id
scalar TxId

type ClaimableHandles {
  reservedHandles: [ReservedClaimableHandle!]!
  canClaimFreeTextHandle: Boolean!
}

type ReservedClaimableHandle {
  id: HandleClaimIdScalar!
  handle: Handle!
  source: String!
  expiry: DateTime!
}

# handle claim id custom scalar type
scalar HandleClaimIdScalar

# handle custom scalar type
scalar Handle

# The claim status
enum ClaimStatus {
  ALREADY_CLAIMED
  CLAIM_FAILED
  NOT_CLAIMED
}

# Cursor custom scalar type
scalar Cursor

# Contract address custom scalar type
scalar EvmAddress

# The challenge request
input ChallengeRequest {
  profileId: ProfileId!
}

scalar ChallengeId

# The auth challenge result
type AuthChallengeResult {
  id: ChallengeId!

  # The text to sign
  text: String!
}

# The access request
input VerifyRequest {
  # The access token
  accessToken: Jwt!
}

# limit custom scalar type
scalar Limit

# The paginated submitter results
type MomokaSubmittersResult {
  items: [MomokaSubmitterResult!]!
  pageInfo: PaginatedResultInfo!
}

type MomokaSubmitterResult {
  address: EvmAddress!
  name: String!
  totalTransactions: Int!
}

type MomokaSummaryResult {
  totalTransactions: Int!
}

type MomokaTransactionsResult {
  items: [MomokaTransaction!]!
  pageInfo: PaginatedResultInfo!
}

union MomokaVerificationStatusUnion =
    MomokaVerificationStatusSuccess
  | MomokaVerificationStatusFailure

type MomokaVerificationStatusSuccess {
  verified: Boolean!
}

type MomokaVerificationStatusFailure {
  status: MomokaValidatorError
}

# The momka validator error
enum MomokaValidatorError {
  NO_SIGNATURE_SUBMITTER
  INVALID_SIGNATURE_SUBMITTER
  TIMESTAMP_PROOF_INVALID_SIGNATURE
  TIMESTAMP_PROOF_INVALID_TYPE
  TIMESTAMP_PROOF_INVALID_DA_ID
  TIMESTAMP_PROOF_NOT_SUBMITTER
  CAN_NOT_CONNECT_TO_BUNDLR
  INVALID_TX_ID
  INVALID_FORMATTED_TYPED_DATA
  BLOCK_CANT_BE_READ_FROM_NODE
  DATA_CANT_BE_READ_FROM_NODE
  SIMULATION_NODE_COULD_NOT_RUN
  SIMULATION_FAILED
  EVENT_MISMATCH
  INVALID_EVENT_TIMESTAMP
  INVALID_TYPED_DATA_DEADLINE_TIMESTAMP
  GENERATED_PUBLICATION_ID_MISMATCH
  INVALID_POINTER_SET_NOT_NEEDED
  POINTER_FAILED_VERIFICATION
  NOT_CLOSEST_BLOCK
  BLOCK_TOO_FAR
  PUBLICATION_NO_POINTER
  PUBLICATION_NONE_DA
  PUBLICATION_NONCE_INVALID
  PUBLICATION_SIGNER_NOT_ALLOWED
  CHAIN_SIGNATURE_ALREADY_USED
  POTENTIAL_REORG
  UNKNOWN
}

union MomokaTransaction =
    MomokaPostTransaction
  | MomokaCommentTransaction
  | MomokaMirrorTransaction
  | MomokaQuoteTransaction

type MomokaPostTransaction {
  transactionId: String!
  submitter: EvmAddress!
  createdAt: DateTime!
  app: App
  verificationStatus: MomokaVerificationStatusUnion!
  profile: Profile!
  publicationId: PublicationId!
}

type MomokaCommentTransaction {
  transactionId: String!
  submitter: EvmAddress!
  createdAt: DateTime!
  app: App
  verificationStatus: MomokaVerificationStatusUnion!
  profile: Profile!
  publicationId: PublicationId!
  commentedOnProfile: Profile!
  commentedOnPublicationId: PublicationId!
}

type MomokaMirrorTransaction {
  transactionId: String!
  submitter: EvmAddress!
  createdAt: DateTime!
  app: App
  verificationStatus: MomokaVerificationStatusUnion!
  profile: Profile!
  publicationId: PublicationId!
  mirrorOfProfile: Profile!
  mirrorOfPublicationId: PublicationId!
}

type MomokaQuoteTransaction {
  transactionId: String!
  submitter: EvmAddress!
  createdAt: DateTime!
  app: App
  verificationStatus: MomokaVerificationStatusUnion!
  profile: Profile!
  publicationId: PublicationId!
  quotedOnProfile: Profile!
  quotedOnPublicationId: PublicationId!
}

input MomokaTransactionsRequest {
  limit: Limit
  cursor: Cursor
  profileId: ProfileId
}

# The paginated result info
type PaginatedResultInfo {
  # Cursor to query the actual results
  prev: Cursor

  # Cursor to query next results
  next: Cursor
}

input MomokaTransactionRequest {
  # The DA transaction id or internal publiation id
  id: String!
}

# AnyPublication metadata filters
input PublicationMetadataFilters {
  # IOS 639-1 language code aka en or it and ISO 3166-1 alpha-2 region code aka US or IT aka en-US or it-IT. You can just filter on language if you wish.
  locale: Locale
  contentWarning: PublicationMetadataContentWarningFilter
  mainContentFocus: [MetadataMainFocus!]
  tags: PublicationMetadataTagsFilter
}

# AnyPublication metadata content warning filters
input PublicationMetadataContentWarningFilter {
  # By default all content warnings will be hidden you can include them in your query by adding them to this array.
  oneOf: [PublicationContentWarning!]
}

# AnyPublication metadata tag filter
input PublicationMetadataTagsFilter {
  # Needs to only match one of
  oneOf: [String!]

  # Needs to match all
  all: [String!]
}

enum ExplorePublicationsOrderBy {
  TOP_COMMENTED
  TOP_COLLECTED_OPEN_ACTION
  TOP_MIRRORED
  TOP_QUOTED
  LATEST
  LENS_CURATED
}

enum ExplorePublicationTypes {
  POST
  COMMENT
  QUOTE
}

input ExplorePublicationsWhere {
  since: UnixTimestamp
  publishedOn: [AppId!]
  publicationTypes: [ExplorePublicationTypes!]
  customFilters: [CustomFiltersTypes!]
  matadata: PublicationMetadataFilters
}

input ExplorePublicationRequest {
  where: ExplorePublicationsWhere
  orderBy: ExplorePublicationsOrderBy!
  limit: Limit
  cursor: Cursor
}

union ExplorePublication = Post | Quote

type PaginatedExplorePublicationResult {
  items: [ExplorePublication!]!
  pageInfo: PaginatedResultInfo!
}

input ExploreProfilesWhere {
  since: UnixTimestamp
  sortCriteria: ProfileSortCriteria!
  customFilters: [CustomFiltersTypes!] = []
}

enum ExploreProfileOrderBy {
  CREATED_ON
  MOST_FOLLOWERS
  LATEST_CREATED
  MOST_POSTS
  MOST_COMMENTS
  MOST_MIRRORS
  MOST_PUBLICATION
  MOST_COLLECTS
}

input ExploreProfilesRequest {
  where: ExploreProfilesWhere
  orderBy: ExploreProfileOrderBy!
  limit: Limit
  cursor: Cursor
}

type PaginatedPublicationReferenceResult {
  items: [PrimaryPublication!]!
  pageInfo: PaginatedResultInfo!
}

# The feed event item filter types
enum FeedEventItemType {
  POST
  COMMENT
  MIRROR
  QUOTE
  COLLECT_POST
  COLLECT_COMMENT
  REACTION_POST
  REACTION_COMMENT
}

input FeedWhere {
  feedEventItemTypes: [FeedEventItemType!]
  publishedOn: [AppId!]
  metadata: PublicationMetadataFilters
  for: ProfileId
}

input FeedRequest {
  where: FeedWhere
  limit: Limit
  cursor: Cursor
}

# The paginated feed result
type PaginatedFeedResult {
  items: [FeedItem!]!
  pageInfo: PaginatedResultInfo!
}

scalar FeedId

type FeedItem {
  id: FeedId!

  root: PrimaryPublication!

  # The elected mirror will be the first Mirror publication within the page results set
  electedMirror: ElectedMirror

  # Sorted by most recent first. Up to page size - 1 mirrors
  mirrors: [MirrorEvent!]!

  # Sorted by most recent first. Resolves defaultProfile and if null omits the wallet collect event from the list.
  collects: [CollectedEvent!]!

  # Sorted by most recent first. Up to page size - 1 reactions
  reactions: [ReactionEvent!]!

  # Sorted by most recent first. Up to page size - 1 comments.
  comments: [Comment!]

  quotes: [Quote!]
}

type ElectedMirror {
  mirrorId: PublicationId!
  by: Profile!
  timestamp: DateTime!
}

type MirrorEvent {
  by: Profile!
  timestamp: DateTime!
}

type CollectedEvent {
  by: Profile!
  timestamp: DateTime!
}

type ReactionEvent {
  by: Profile!
  reaction: ReactionTypes!
  timestamp: DateTime!
}

union FeedHighlight = Post | Quote

# The paginated result
type PaginatedFeedHighlightsResult {
  items: [FeedHighlight!]!
  pageInfo: PaginatedResultInfo!
}

input FeedHighlightWhere {
  publishedOn: [AppId!]
  metadata: PublicationMetadataFilters
}

input FeedHighlightsRequest {
  where: FeedHighlightWhere
  limit: Limit
  cursor: Cursor
}

input FollowingRequest {
  for: ProfileId!
  limit: Limit
  cursor: Cursor
}

input FollowersRequest {
  of: ProfileId!
  limit: Limit
  cursor: Cursor
}

input MutualFollowersRequest {
  # The profile id your viewing
  viewing: ProfileId!

  # The profile id you want the result to come back as your viewing from
  observer: ProfileId!

  limit: Limit
  cursor: Cursor
}

# The paginated profile result
type PaginatedProfileResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
}

# TODO! NOT DONE
input ApprovedModuleAllowanceAmountRequest {
  # The contract addresses for the module approved currencies you want to find information on about the user
  currencies: [EvmAddress!]!
  openActionModules: [OpenActionModules!] = []
  unknownCollectModules: [EvmAddress!] = []
  followModules: [FollowModules!] = []
  unknownFollowModules: [EvmAddress!] = []
  referenceModules: [ReferenceModules!] = []
  unknownReferenceModules: [EvmAddress!] = []
}

# TODO! NOT DONE
type ApprovedAllowanceAmount {
  currency: EvmAddress!
  module: String!
  EvmAddress: EvmAddress!
  allowance: String!
}

# TODO! NOT DONE
input GenerateModuleCurrencyApprovalDataRequest {
  currency: EvmAddress!

  # Floating point number as string (e.g. 42.009837). The server will move its decimal places for you
  value: String!
  openActionModule: OpenActionModules
  unknownCollectModule: EvmAddress
  followModule: FollowModules
  unknownFollowModule: EvmAddress
  referenceModule: ReferenceModules
  unknownReferenceModule: EvmAddress
}

# TODO! NOT DONE
type GenerateModuleCurrencyApproval {
  to: EvmAddress!
  from: EvmAddress!
  data: BlockchainData!
}

type SupportedModules {
  openActionsModules: [SupportedModule!]!
  followModules: [SupportedModule!]!
  referenceModules: [SupportedModule!]!
}

type SupportedModule {
  moduleName: String!
  contract: NetworkAddress!
  inputInput: [ModuleInfo!]!
  redeemInput: [ModuleInfo!]!
  returnDataInput: [ModuleInfo!]!
  isTypeSafe: Boolean!
}

type ModuleInfo {
  name: String!
  type: String!
}

# The NFT gallery input
input NftGalleriesRequest {
  # The profile id
  for: ProfileId!
}

# Nft gallery id type
scalar NftGalleryId

# The NFT gallery
type NftGallery {
  # The NFT gallery id
  id: NftGalleryId!

  # The NFT gallery name
  name: String!

  # The NFTs in the gallery
  items: [NFT!]!

  # The creation date
  createdAt: DateTime!

  # The last update date
  updatedAt: DateTime!
}

input NetworkAddressInput {
  address: EvmAddress!
  chainId: ChainId!
}

input NFTsRequestWhere {
  for: ProfileId

  # Search query. Has to be part of a collection name
  query: String

  # Include only filtered collection addresses in the search. Overrides `EvmAddress`
  includeCollections: [NetworkAddressInput!] = []

  # Exclude filtered collection addresses from the search. Cannot be used together ith `includeCollections`
  excludeCollections: [NetworkAddressInput!] = []

  chainIds: [ChainId!] = [5, 80001]
}

input NFTsRequest {
  where: NFTsRequestWhere
  limit: Limit
  cursor: Cursor
}

# Paginated nft results
type NFTsResult {
  items: [NFT!]!
  pageInfo: PaginatedResultInfo!
}

# Nft ownership id type
scalar NftOwnershipChallengeId

# NFT ownership challenge result
type NftOwnershipChallengeResult {
  # Id of the nft ownership challenge
  id: NftOwnershipChallengeId!

  text: String!
}

input NftOwnershipChallengeRequest {
  # The wallet address which owns the NFT
  for: EvmAddress!

  nfts: [NftOwnershipChallenge!]!
}

input NftOwnershipChallenge {
  # EvmAddress for nft
  contract: NetworkAddressInput!

  # Token id for NFT
  tokenId: String!
}

input ProfileRequest {
  # The profile id
  profileId: ProfileId

  # The handle for the profile
  handle: Handle
}

input ProfilesRequestWhere {
  ownedBy: [EvmAddress!]
  profileIds: [ProfileId!]
  whoMirroredPublication: PublicationId
  whoQuotedPublication: PublicationId
  """
  Direct comments only
  """
  whoCommentedOn: PublicationId
}

input ProfilesRequest {
  where: ProfilesRequestWhere
  limit: Limit
  cursor: Cursor
}

input RecommendedProfileRequestWhere {
  for: ProfileId
}

input RecommendedProfileRequest {
  where: RecommendedProfileRequestWhere
  disableML: Boolean = false
  shuffle: Boolean = false
}

enum PublicationTypes {
  POST
  COMMENT
  QUOTE
  MIRROR
}

input ActedByFilter {
  who: ProfileId!
  openAction: [OpenActionFilter!]!
}

input PublicationsWhere {
  from: [ProfileId!]

  publicationTypes: [PublicationTypes!]

  commentsOf: PublicationId

  mirrorOf: PublicationId

  publishedOn: [AppId!]

  withOpenActions: [OpenActionFilter!]

  actedBy: [OpenActionFilter!]

  publicationIds: [PublicationId!]

  metadata: PublicationMetadataFilters

  customFilters: [CustomFiltersTypes!] = []
}

enum PublicationsOrderBy {
  TOP_COMMENTED
  TOP_COLLECTED_OPEN_ACTION
  TOP_MIRRORED
  TOP_QUOTED
  COMMENT_OF_QUERY_RANKING
  LATEST
}

input PublicationsRequest {
  where: PublicationsWhere

  # The comment ordering type - only used when you use commentsOf
  orderBy: PublicationsOrderBy = COMMENT_RANKING

  # The comment ranking filter, you can use  - only used when you use commentsOf + commentsOfOrdering=ranking
  commentsRankingFilter: CommentRankingFilter

  limit: Limit
  cursor: Cursor
}

# The comment ranking filter types
enum CommentRankingFilter {
  NONE_RELEVANT
  RELEVANT
}

# The paginated publication result
type PaginatedPublicationsResult {
  items: [AnyPublication!]!
  pageInfo: PaginatedResultInfo!
}

input PublicationRequest {
  # The publication id
  for: PublicationId

  # The tx hash
  txHash: TxHash
}

input WhoActedPublicationWhere {
  anyOf: [OpenActionFilter!]!
}

input WhoActedPublicationRequest {
  on: PublicationId!
  where: WhoActedPublicationWhere
  limit: Limit
  cursor: Cursor
}

# The paginated wallet result
type PaginatedPublicationsTagsResult {
  items: [TagResult!]!
  pageInfo: PaginatedResultInfo!
}

# The publication tag
scalar PublicationTag

# The social comment
type TagResult {
  # The tag
  tag: PublicationTag!

  # The total amount of publication tagged
  total: Int!
}

input PublicationsTagsWhere {
  publishedOn: [AppId!]
}

input PublicationsTagsRequest {
  where: PublicationsTagsWhere
  orderBy: TagSortCriteria!
  limit: Limit
  cursor: Cursor
}

# The publications tags sort criteria
enum TagSortCriteria {
  MOST_POPULAR
  ALPHABETICAL
}

input ProfileBookmarksWhere {
  publishedOn: [AppId!]
  metadata: PublicationMetadataFilters
}

input ProfileBookmarksRequest {
  where: ProfileBookmarksWhere
  limit: Limit
  cursor: Cursor
}

input PublicationForYouRequest {
  for: ProfileId!
  limit: Limit
  cursor: Cursor
}

union PublicationForYou = Post | Quote

type PaginatedForYouResult {
  items: [PublicationForYou!]!
  pageInfo: PaginatedResultInfo!
}

input WhoReactedPublicationWhere {
  anyOf: [ReactionTypes!]
}

input WhoReactedPublicationRequest {
  for: PublicationId!
  where: WhoReactedPublicationWhere
  limit: Limit
  cursor: Cursor
}

type PaginatedWhoReactedResult {
  items: [ProfileReactedResult!]!
  pageInfo: PaginatedResultInfo!
}

# The reaction id
scalar ReactionId

# The Profile
type ProfileReactedResult {
  profile: Profile!

  # The reaction
  reactions: [ReactedResult]!
}

type ReactedResult {
  # The reaction
  reaction: ReactionTypes!

  # The reaction
  reactedAt: DateTime!
}

# The relay role key
enum RelayRoleKey {
  CREATE_PROFILE
  DISPATCHER_1
  DISPATCHER_2
  DISPATCHER_3
  DISPATCHER_4
  DISPATCHER_5
  DISPATCHER_6
  DISPATCHER_7
  DISPATCHER_8
  DISPATCHER_9
  DISPATCHER_10
  PROXY_ACTION_COLLECT_1
  PROXY_ACTION_COLLECT_2
  PROXY_ACTION_COLLECT_3
  PROXY_ACTION_COLLECT_4
  PROXY_ACTION_COLLECT_5
  PROXY_ACTION_COLLECT_6
  PROXY_ACTION_FOLLOW_1
  PROXY_ACTION_FOLLOW_2
  PROXY_ACTION_FOLLOW_3
  PROXY_ACTION_FOLLOW_4
  PROXY_ACTION_FOLLOW_5
  PROXY_ACTION_FOLLOW_6
  PROXY_ACTION_FOLLOW_7
  PROXY_ACTION_FOLLOW_8
  PROXY_ACTION_FOLLOW_9
  PROXY_ACTION_FOLLOW_10
  WITH_SIG_1
  WITH_SIG_2
  WITH_SIG_3
  ZK_RELAYER_1
}

type RelayQueueResult {
  # The relayer name
  relayer: RelayRoleKey!

  # The address of the relay
  address: EvmAddress!

  # The queue on the relay
  queue: Float!
}

input RevenueFromPublicationsWhere {
  publishedOn: [AppId!]
  anyOf: [OpenActionFilter!]
  fromCollects: Boolean
  metadata: PublicationMetadataFilters
  publicationTypes: [PublicationTypes!]
}

input RevenueFromPublicationsRequest {
  for: ProfileId!
  where: RevenueFromPublicationsWhere
  limit: Limit
  cursor: Cursor
}

# The paginated revenue result
type RevenueFromPublicationsResult {
  items: [PublicationRevenue!]!
  pageInfo: PaginatedResultInfo!
}

type PublicationRevenue {
  publication: AnyPublication!
  revenue: [RevenueAggregate!]
}

type RevenueAggregate {
  total: Amount!
}

input PublicationRevenueRequest {
  for: PublicationId!
}

# The social comment
type PublicationRevenue {
  revenue: [RevenueAggregate!]
}

input FollowRevenueRequest {
  for: ProfileId!
}

type FollowRevenueResult {
  revenues: [RevenueAggregate!]!
}

input PublicationSearchWhere {
  publishedOn: [AppId!]
  customFilters: [CustomFiltersTypes!]
  publicationTypes: [PublicationTypes!]
}

input PublicationSearchRequest {
  query: String!
  where: PublicationSearchWhere
  limit: Limit
  cursor: Cursor
}

type PublicationSearchResult {
  items: [PrimaryPublication!]!
  pageInfo: PaginatedResultInfo!
}

input ProfileSearchWhere {
  customFilters: [CustomFiltersTypes!]
}

input ProfileSearchRequest {
  query: String!
  where: ProfileSearchWhere
  limit: Limit
  cursor: Cursor
}

# Nonce custom scalar type
scalar Nonce

type UserSigNonces {
  lensHubOnChainSigNonce: Nonce!
  peripheryOnChainSigNonce: Nonce!
}

input LensTransactionStatusRequest {
  # Tx hash.. if your using the broadcaster you should use txId due to gas price upgrades
  txHash: TxHash

  # Tx id.. if your using the broadcaster you should always use this field
  txId: TxId
}

enum LensTransactionStatus {
  PROGRESSING
  COMPLETE
  FAILED
}

enum LensMetadataTransactionFailureTypes {
  REVERTED
  METADATA_ERROR
}

type LensMetadataTransaction {
  status: LensTransactionStatus!
  metadataFailedReason: LensMetadataTransactionFailureTypes
  extraInfo: String
}

enum LensTransactionFailureTypes {
  REVERTED
}

type LensTransaction {
  status: LensTransactionStatus!
  txHash: TxHash!
  txReceipt: TransactionReceipt
  reason: LensTransactionFailureTypes
  extraInfo: String
}

union LensTransactionResult = LensTransaction | LensMetadataTransaction

# end

type TransactionReceipt {
  to: EvmAddress
  from: EvmAddress!
  EvmAddress: EvmAddress
  transactionIndex: Int!
  root: String
  gasUsed: String!
  logsBloom: String!
  blockHash: String!
  transactionHash: TxHash!
  logs: [Log!]!
  blockNumber: Int!
  confirmations: Int!
  cumulativeGasUsed: String!
  effectiveGasPrice: String!
  byzantium: Boolean!
  type: Int!
  status: Int
}

type Log {
  blockNumber: Int!
  blockHash: String!
  transactionIndex: Int!
  removed: Boolean!
  address: EvmAddress!
  data: String!
  topics: [String!]!
  transactionHash: TxHash!
  logIndex: Int!
}

type PublicationValidateMetadataResult {
  valid: Boolean!

  # If `valid` is false it will put a reason why here
  reason: String
}

input ValidatePublicationMetadataRequest {
  rawURL: Url
  json: String
}

scalar NotificationId

type FutureProofNotification {
  id: NotificationId!
}

type ReactionNotification {
  id: NotificationId!
  reactions: [ProfileReactedResult!]!
  publication: PrimaryPublication!
}

type CommentNotification {
  id: NotificationId!
  comment: Comment!
}

type ProfileMirrorResult {
  mirrorId: PublicationId!
  mirroredAt: DateTime!
  profile: Profile!
}

type MirrorNotification {
  id: NotificationId!
  mirrors: [ProfileMirrorResult!]!
  publication: PrimaryPublication!
}

type QuoteNotification {
  id: NotificationId!
  quote: Quote!
}

type ProfileActedResult {
  profile: Profile!
  actions: OpenActionResult!
}

type ActedNotification {
  id: NotificationId!
  actions: [ProfileActedResult!]!
  publication: AnyPublication!
}

type FollowNotification {
  id: NotificationId!
  followers: [Profile!]!
}

type MentionNotification {
  id: NotificationId!
  publication: PrimaryPublication!
}

union Notification =
    ReactionNotification
  | CommentNotification
  | MirrorNotification
  | QuoteNotification
  | ActedNotification
  | FollowNotification
  | MentionNotification
  | FutureProofNotification

# The notification filter types
enum NotificationTypes {
  MIRRORED
  MENTIONED
  QUOTED
  COMMENTED
  COLLECT_ACTED
  OTHER_ACTED
  FOLLOWED
  REACTED
}

input NotificationWhere {
  publishedOn: [AppId!]
  customFilters: [CustomFiltersTypes!] = []
  highSignalFilter: Boolean = true
  notificationTypes: [NotificationTypes!]
}

input NotificationRequest {
  where: NotificationWhere

  limit: Limit
  cursor: Cursor
}

type PaginatedNotificationResult {
  items: [Notification!]!
  pageInfo: PaginatedResultInfo!
}

## QUERY ENDS

## Lens v2 queries

input ProfileManagersRequest {
  profile: ProfileId!
}

type PaginatedProfileManagersResult {
  items: [EvmAddress!]!
  pageInfo: PaginatedResultInfo!
}

input OwnedHandlesRequest {
  address: EvmAddress!
}

type PaginatedHandlesResult {
  items: [Handle!]!
  pageInfo: PaginatedResultInfo!
}

input ManagedProfilesRequest {
  address: EvmAddress!
}

type Query {
  # internal
  alreadyInvited(request: AlreadyInvitedCheckRequest!): Boolean!
  invited: [InvitedResult!]!
  rel(request: RelRequest!): Void
  cur(request: CurRequest!): [String!]!
  gdm(request: GdmRequest!): [Url!]!
  gct(request: GctRequest!): [String!]!
  iss(request: PriRequest!): PrfResponse!
  intotal(request: InTotalRequest!): Int!
  claimableHandles: ClaimableHandles!
  claimableStatus: ClaimStatus!
  ping: String!
  internalPin(request: InternalPinRequest!): [InternalPinResult!]!
  relayQueues: [RelayQueueResult!]!
  # internal

  profileManagers(request: ProfileManagersRequest!): PaginatedProfileManagersResult!
  ownedHandles(request: OwnedHandlesRequest!): PaginatedHandlesResult!
  managedProfiles(request: ManagedProfilesRequest!): PaginatedProfileResult!

  # auth
  challenge(request: ChallengeRequest!): AuthChallengeResult!
  verify(request: VerifyRequest!): Boolean!

  # transactions
  txIdToTxHash(txId: TxId!): TxHash!
  lensTransactionStatus(request: LensTransactionStatusRequest!): LensTransactionResult!

  # Momoka stats
  momokaSubmitters: MomokaSubmittersResult!
  momokaSummary: MomokaSummaryResult!
  momokaTransactions(request: MomokaTransactionsRequest): MomokaTransactionsResult!
  momokaTransaction(request: MomokaTransactionRequest!): MomokaTransaction

  # Discovery
  explorePublications(request: ExplorePublicationRequest!): PaginatedExplorePublicationResult!
  exploreProfiles(request: ExploreProfilesRequest!): PaginatedProfileResult!
  feed(request: FeedRequest!): PaginatedFeedResult!
  feedHighlights(request: FeedHighlightsRequest!): PaginatedFeedHighlightsResult!

  following(request: FollowingRequest!): PaginatedProfileResult!
  followers(request: FollowersRequest!): PaginatedProfileResult!
  mutualFollowers(request: MutualFollowersRequest!): PaginatedProfileResult!

  # modules
  currencies: [Erc20!]!
  # TODO! come back to this!
  approvedModuleAllowanceAmount(
    request: ApprovedModuleAllowanceAmountRequest!
  ): [ApprovedAllowanceAmount!]!
  # TODO! come back to this!
  generateModuleCurrencyApprovalData(
    request: GenerateModuleCurrencyApprovalDataRequest!
  ): GenerateModuleCurrencyApproval!
  supportedModules: SupportedModules!

  # NFTs
  # Get all NFT galleries for a profile
  nftGalleries(request: NftGalleriesRequest!): [NftGallery!]!
  # Get the NFTs that the given wallet or profileId owns. Only supports Ethereum and Polygon NFTs. Note excludeFollowers is set to true by default, so the result will not include Lens Follower NFTs unless explicitly requested.
  nfts(request: NFTsRequest!): NFTsResult!
  notifications(request: NotificationRequest!): PaginatedNotificationResult!

  # Profiles
  profiles(request: ProfilesRequest!): PaginatedProfileResult!
  profile(request: ProfileRequest!): Profile

  recommendedProfiles(request: RecommendedProfileRequest): [Profile!]!
  validatePublicationMetadata(
    request: ValidatePublicationMetadataRequest!
  ): PublicationValidateMetadataResult!
  publications(request: PublicationsRequest!): PaginatedPublicationsResult!
  publication(request: PublicationRequest!): AnyPublication
  whoActedPublication(request: WhoActedPublicationRequest!): PaginatedProfileResult!
  publicationsTags(request: PublicationsTagsRequest!): PaginatedPublicationsTagsResult!
  profileBookmarks(request: ProfileBookmarksRequest!): PaginatedPublicationsResult!
  forYou(request: PublicationForYouRequest!): PaginatedForYouResult!
  whoReactedPublication(request: WhoReactedPublicationRequest!): PaginatedWhoReactedResult!
  revenueFromPublications(request: RevenueFromPublicationsRequest!): RevenueFromPublicationsResult!
  revenueForPublication(request: PublicationRevenueRequest!): PublicationRevenue
  followRevenues(request: FollowRevenueRequest!): FollowRevenueResult!
  searchProfile(request: ProfileSearchRequest!): PaginatedProfileResult!
  searchPublication(request: PublicationSearchRequest!): PaginatedPublicationReferenceResult!
  userSigNonces: UserSigNonces!
}

input InviteRequest {
  invites: [EvmAddress!]!
  secret: String!
}

input AchRequest {
  secret: String!
  ethereumAddress: EvmAddress!
  handle: CreateHandle
  freeTextHandle: Boolean
  overrideTradeMark: Boolean!
  overrideAlreadyClaimed: Boolean!
}

# create handle custom scalar type
scalar CreateHandle

input HelRequest {
  secret: String!
  handle: Handle!
  remove: Boolean!
}

input GddRequest {
  secret: String!
  domain: Url!
}

input GciRequest {
  secret: String!
  hhh: String!
  ttt: String!
}

input GcrRequest {
  secret: String!
  hhh: String!
  ttt: String!
}

input PrfRequest {
  secret: String!
  hhh: String!
  ss: Boolean!
  dd: Boolean!
}

input NniRequest {
  secret: String!
  n: [Nfi!]!
}

input Nfi {
  c: EvmAddress!
  i: ChainId!
}

input NnvRequest {
  secret: String!
  n: [Nfi!]!
}

input InRequest {
  secret: String!
  ethereumAddress: EvmAddress!
  numInvites: Int!
}

# IpfsCid scalar type
scalar IpfsCid

scalar Signature

# The signed auth challenge
input SignedAuthChallenge {
  id: ChallengeId!

  # The signature
  signature: Signature!
}

# The authentication result
type AuthenticationResult {
  # The access token
  accessToken: Jwt!

  # The refresh token
  refreshToken: Jwt!
}

# The refresh request
input RefreshRequest {
  # The refresh token
  refreshToken: Jwt!
}

# Broadcast scalar id type
scalar BroadcastId

input BroadcastRequest {
  id: BroadcastId!
  signature: Signature!
}

type RelayError {
  reason: RelayErrorReasons!
}

# Relay error reason
enum RelayErrorReasons {
  RATE_LIMITED
  FAILED
  EXPIRED
  WRONG_WALLET_SIGNED
  APP_GASLESS_NOT_ALLOWED
}

# The relayer result
type RelaySuccess {
  # The tx hash - you should use the `txId` as your identifier as gas prices can be upgraded meaning txHash will change
  txHash: TxHash!

  # The tx id
  txId: TxId!
}

union RelayResult = RelaySuccess | RelayError

# Relay error reason
enum LensProfileManagerRelayErrorReasons {
  RATE_LIMITED
  FAILED
  EXPIRED
  WRONG_WALLET_SIGNED
  APP_GASLESS_NOT_ALLOWED
  REQUIRES_SIGNATURE
}

type LensProfileManagerRelayError {
  reason: LensProfileManagerRelayErrorReasons
}

union LensProfileManagerRelayResult = RelaySuccess | LensProfileManagerRelayError

# The da id
scalar MomokaId

type CreateMomokaPublicationResult {
  # The id of the post
  id: PublicationId!

  # The proof for the DA
  proof: MomokaProof!

  # The data availability id
  momokaId: MomokaId!
}

union BroadcastMomokaResult = CreateMomokaPublicationResult | RelayError

enum ClaimRelayErrorReasons {
  FAILED
  HANDLE_TAKEN
}

type ClaimRelayError {
  reason: RelayErrorReasons!
}

union ClaimRelayResult = RelaySuccess | ClaimRelayError

input ClaimHandleRequest {
  id: HandleClaimIdScalar

  freeTextHandle: CreateHandle

  # The follow module
  followModule: FollowModuleInput
}

input FollowModuleInput {
  # The follower fee follower module
  feeFollowModule: FeeFollowModuleInput

  # The profile follow module
  profileFollowModule: Boolean

  # The revert follow module
  revertFollowModule: Boolean

  # The empty follow module
  freeFollowModule: Boolean

  # A unknown follow module
  unknownFollowModule: UnknownFollowModuleInput
}

input NetworkAddressInput {
  address: EvmAddress!
  chainId: ChainId!
}

input AmountInput {
  # Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal.
  value: String!

  # The currency
  currency: NetworkAddressInput!
}

input FeeFollowModuleInput {
  # The follow module amount info
  amount: AmountInput!

  # The follow module recipient address
  recipient: EvmAddress!
}

input UnknownFollowModuleInput {
  address: EvmAddress!

  # The encoded data to submit with the module
  data: BlockchainData!
}

# The verify webhook result status type
enum IdKitPhoneVerifyWebhookResultStatusType {
  SUCCESS
  ALREADY_VERIFIED
}

input IdKitPhoneVerifyWebhookRequest {
  sharedSecret: String!
  worldcoin: WorldcoinPhoneVerifyWebhookRequest
}

input WorldcoinPhoneVerifyWebhookRequest {
  nullifierHash: String!
  signalType: WorldcoinPhoneVerifyType!
  signal: EvmAddress!
}

# The worldcoin signal type
enum WorldcoinPhoneVerifyType {
  PHONE
  ORB
}

input TypedDataOptions {
  # If you wish to override the nonce for the sig if you want to do some clever stuff in the client
  overrideSigNonce: Nonce!
}

input SetProfileManagerRequest {
  # means you can create a better UX experience
  for: ProfileId!

  remove: [EvmAddress!]
  add: [EvmAddress!]

  lens: Boolean
}

# The broadcast item
type CreateSetProfileManagerBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateSetProfileManagerEIP712TypedData!
}

type CreateSetProfileManagerEIP712TypedData {
  # The types
  types: CreateSetProfileManagerEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateSetProfileManagerEIP712TypedDataValue!
}

# The set dispatcher eip 712 typed data types
type CreateSetProfileManagerEIP712TypedDataTypes {
  ChangeDelegatedExecutorsConfigWithSig: [EIP712TypedDataField!]!
}

# The eip 712 typed data field
type EIP712TypedDataField {
  # The name of the typed data field
  name: String!

  # The type of the typed data field
  type: String!
}

# The eip 712 typed data domain
type EIP712TypedDataDomain {
  # The name of the typed data domain
  name: String!

  # The chainId
  chainId: ChainId!

  # The version
  version: String!

  # The verifying contract
  verifyingContract: EvmAddress!
}

# TODO! NEEDS TO CHANGE LENS V2
type CreateSetProfileManagerEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  #   profileId: ProfileId!
  #   dispatcher: evmAddress!
}

input FollowRequest {
  follow: [Follow!]!
}

input Follow {
  profile: ProfileId!
  followModule: FollowModuleRedeemInput
}

input FollowModuleRedeemInput {
  # The follower fee follower module
  feeFollowModule: FeeFollowModuleRedeemInput

  # The profile follower module
  profileFollowModule: ProfileFollowModuleRedeemInput

  # A unknown follow module
  unknownFollowModule: UnknownFollowModuleRedeemInput
}

input FeeFollowModuleRedeemInput {
  # The expected amount to pay
  amount: AmountInput!
}

input ProfileFollowModuleRedeemInput {
  # The profile id to use to follow this profile
  profileId: ProfileId!
}

input UnknownFollowModuleRedeemInput {
  # The encoded data to submit with the module
  data: BlockchainData!
}

# The broadcast item
type CreateFollowBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateFollowEIP712TypedData!
}

# The create follow eip 712 typed data
type CreateFollowEIP712TypedData {
  # The types
  types: CreateFollowEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateFollowEIP712TypedDataValue!
}

# The create follow eip 712 typed data types
type CreateFollowEIP712TypedDataTypes {
  FollowWithSig: [EIP712TypedDataField!]!
}

# TODO! NEEDS TO CHANGE LENS V2
# The create follow eip 712 typed data value
type CreateFollowEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileIds: [ProfileId!]!
  datas: [BlockchainData!]!
}

# The broadcast item
type CreateUnfollowBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateUnfollowEIP712TypedData!
}

# The create burn eip 712 typed data
type CreateUnfollowEIP712TypedData {
  # The types
  types: CreateUnfollowEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateUnfollowEIP712TypedDataValue!
}

# The create burn eip 712 typed data types
type CreateUnfollowEIP712TypedDataTypes {
  UnfollowWithSig: [EIP712TypedDataField!]!
}

# TODO! NEEDS TO CHANGE LENS V2
# The create burn eip 712 typed data value
type CreateUnfollowEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  tokenId: String!
}

input UnfollowRequest {
  profile: ProfileId!
}

# The broadcast item
type CreateSetFollowModuleBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateSetFollowModuleEIP712TypedData!
}

# The set follow module eip 712 typed data
type CreateSetFollowModuleEIP712TypedData {
  # The types
  types: CreateSetFollowModuleEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateSetFollowModuleEIP712TypedDataValue!
}

# The set follow module eip 712 typed data types
type CreateSetFollowModuleEIP712TypedDataTypes {
  SetFollowModuleWithSig: [EIP712TypedDataField!]!
}

# TODO! NEEDS TO CHANGE LENS V2
# The set follow module eip 712 typed data value
type CreateSetFollowModuleEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  followModule: EvmAddress!
  followModuleInitData: FollowModuleData!
}

input CreateSetFollowModuleRequest {
  # The follow module info
  followModule: FollowModuleInput!
}

# The broadcast item
type CreateOpenActionActBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateOpenActionActEIP712TypedData!
}

type CreateOpenActionActEIP712TypedData {
  # The types
  types: CreateOpenActionActEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateOpenActionActEIP712TypedDataValue!
}

type CreateOpenActionActEIP712TypedDataTypes {
  CollectWithSig: [EIP712TypedDataField!]!
}

# TODO! NEEDS TO CHANGE LENS V2
type CreateOpenActionActEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  pubId: ContractPublicationId!
  data: BlockchainData!
}

scalar PublicationId

scalar ContractPublicationId

input UnknownOpenActionActEquest {
  address: EvmAddress!
  data: BlockchainData
}

input CreateOpenActionActRequest {
  for: PublicationId!

  multirecipientCollectOpenAction: Boolean

  simpleCollectOpenAction: Boolean

  unknownOpenAction: UnknownOpenActionActEquest
}

# The broadcast item
type CreateSetProfileMetadataURIBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateSetProfileMetadataURIEIP712TypedData!
}

# The set follow nft uri eip 712 typed data
type CreateSetProfileMetadataURIEIP712TypedData {
  # The types
  types: CreateSetProfileMetadataURIEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateSetProfileMetadataURIEIP712TypedDataValue!
}

# The set follow nft uri eip 712 typed data types
type CreateSetProfileMetadataURIEIP712TypedDataTypes {
  SetProfileMetadataURIWithSig: [EIP712TypedDataField!]!
}

# TODO! NEEDS TO CHANGE LENS V2
# The set follow nft uri eip 712 typed data value
type CreateSetProfileMetadataURIEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  metadata: Url!
}

input CreateSetProfileMetadataURIRequest {
  # The metadata uploaded somewhere passing in the url to reach it
  metadata: Url!
}

# The broadcast item
type CreateSetProfileImageUriBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateSetProfileImageUriEIP712TypedData!
}

# The set profile uri eip 712 typed data
type CreateSetProfileImageUriEIP712TypedData {
  # The types
  types: CreateSetProfileImageUriEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateSetProfileImageUriEIP712TypedDataValue!
}

# The set profile image uri eip 712 typed data types
type CreateSetProfileImageUriEIP712TypedDataTypes {
  SetProfileImageURIWithSig: [EIP712TypedDataField!]!
}

# The set profile uri eip 712 typed data value
type CreateSetProfileImageUriEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  imageURI: Url!
}

input NFTOwnershipProof {
  # Id of the nft ownership challenge
  id: NftOwnershipChallengeId!

  # The signature
  signature: Signature!
}

input UpdateProfileImageRequest {
  # The url to the image if offline
  url: Url

  # The nft data
  nftData: NFTOwnershipProof
}

input DeleteProfileRequest {
  for: ProfileId!
}

# The broadcast item
type CreateDeleteProfileBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # TODO! FIND
  # The typed data
  typedData: CreateDeleteEIP712TypedData!
}

input CreateMomokaPostRequest {
  # The metadata contentURI resolver
  contentURI: Url!
}

input CreateMomokaCommentRequest {
  # AnyPublication your commenting on
  commentOn: PublicationId!

  # The metadata contentURI resolver
  contentURI: Url!
}

input CreateOnChainCommentRequest {
  # AnyPublication your commenting on
  commentOn: PublicationId!

  # The metadata contentURI resolver
  contentURI: Url!
}

union RelayMomokaResult = CreateMomokaPublicationResult | RelayError

input CreateMomokaMirrorRequest {
  # Profile id which will broadcast the mirror
  from: ProfileId!

  # The publication to mirror
  mirror: PublicationId!
}

input CreateOnChainPostRequest {
  # The metadata uploaded somewhere passing in the url to reach it
  contentURI: Url!

  # The collect module
  openActionModule: [OpenActionModuleInput!]!

  # The reference module
  referenceModule: ReferenceModuleInput
}

# The broadcast item
type CreateMirrorBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateMirrorEIP712TypedData!
}

# The mirror eip 712 typed data
type CreateMirrorEIP712TypedData {
  # The types
  types: CreateMirrorEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateMirrorEIP712TypedDataValue!
}

# The mirror eip 712 typed data types
type CreateMirrorEIP712TypedDataTypes {
  MirrorWithSig: [EIP712TypedDataField!]!
}

# TODO! NEEDS TO CHANGE LENS V2
# The mirror eip 712 typed data value
type CreateMirrorEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  profileIdPointed: ProfileId!
  pubIdPointed: ContractPublicationId!
  referenceModuleData: ReferenceModuleData!
  referenceModule: EvmAddress!
  referenceModuleInitData: ReferenceModuleData!
}

# The broadcast item
type CreatePostBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreatePostEIP712TypedData!
}

# The create post eip 712 typed data
type CreatePostEIP712TypedData {
  # The types
  types: CreatePostEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreatePostEIP712TypedDataValue!
}

# The create post eip 712 typed data types
type CreatePostEIP712TypedDataTypes {
  PostWithSig: [EIP712TypedDataField!]!
}

# The create post eip 712 typed data value
type CreatePostEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  contentURI: PublicationUrl!
  collectModule: EvmAddress!
  collectModuleInitData: CollectModuleData!
  referenceModule: EvmAddress!
  referenceModuleInitData: ReferenceModuleData!
}

# AnyPublication url scalar type
scalar PublicationUrl

# The broadcast item
type CreateCommentBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateCommentEIP712TypedData!
}

# The create comment eip 712 typed data
type CreateCommentEIP712TypedData {
  # The types
  types: CreateCommentEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateCommentEIP712TypedDataValue!
}

# The create comment eip 712 typed data types
type CreateCommentEIP712TypedDataTypes {
  CommentWithSig: [EIP712TypedDataField!]!
}

# TODO! NEEDS TO CHANGE LENS V2
# The create comment eip 712 typed data value
type CreateCommentEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileId: ProfileId!
  contentURI: PublicationUrl!
  profileIdPointed: ProfileId!
  pubIdPointed: ContractPublicationId!
  collectModule: EvmAddress!
  collectModuleInitData: CollectModuleData!
  referenceModule: EvmAddress!
  referenceModuleInitData: ReferenceModuleData!
  referenceModuleData: ReferenceModuleData!
}

input CreateOnChainMirrorRequest {
  # AnyPublication id of what you want to mirror on remember if this is a comment it will be that as the id
  on: PublicationId!

  # The reference module info
  referenceModule: ReferenceModuleInput
}

input HidePublicationRequest {
  # AnyPublication id
  publicationId: PublicationId!
}

input CreateOnChainCommentRequest {
  # AnyPublication id of what your comments on remember if this is a comment you commented on it will be that as the id
  on: PublicationId!

  # The metadata contentURI resolver
  contentURI: Url!

  # The collect module
  openActionModule: [OpenActionModuleInput!]!

  # The reference module
  referenceModule: ReferenceModuleInput
}

input PublicationNotInterestedRequest {
  # The publication id
  on: PublicationId!
}

input PublicationBookmarkRequest {
  # The publication id
  on: PublicationId!
}

input ReactionRequest {
  # The reaction
  reaction: ReactionTypes!

  # The publication id
  for: PublicationId!
}

input ReportPublicationRequest {
  for: PublicationId!
  reason: ReportingReasonInputInput!
  additionalComments: String
}

input ReportingReasonInputInput {
  sensitiveReason: SensitiveReasonInputInput
  illegalReason: IllegalReasonInputInput
  fraudReason: FraudReasonInputInput
  spamReason: SpamReasonInputInput
}

input SensitiveReasonInputInput {
  reason: PublicationReportingReason!
  subreason: PublicationReportingSensitiveSubreason!
}

# AnyPublication reporting reason
enum PublicationReportingReason {
  SENSITIVE
  ILLEGAL
  FRAUD
  SPAM
}

# AnyPublication reporting sensitive subreason
enum PublicationReportingSensitiveSubreason {
  NSFW
  OFFENSIVE
}

input IllegalReasonInputInput {
  reason: PublicationReportingReason!
  subreason: PublicationReportingIllegalSubreason!
}

# AnyPublication reporting illegal subreason
enum PublicationReportingIllegalSubreason {
  ANIMAL_ABUSE
  HUMAN_ABUSE
  VIOLENCE
  THREAT_INDIVIDUAL
  DIRECT_THREAT
}

input FraudReasonInputInput {
  reason: PublicationReportingReason!
  subreason: PublicationReportingFraudSubreason!
}

# AnyPublication reporting fraud subreason
enum PublicationReportingFraudSubreason {
  SCAM
  IMPERSONATION
}

input SpamReasonInputInput {
  reason: PublicationReportingReason!
  subreason: PublicationReportingSpamSubreason!
}

# AnyPublication reporting spam subreason
enum PublicationReportingSpamSubreason {
  MISLEADING
  MISUSE_HASHTAGS
  UNRELATED
  REPETITIVE
  FAKE_ENGAGEMENT
  MANIPULATION_ALGO
  LOW_SIGNAL
  SOMETHING_ELSE
}

# The input for creating a new NFT gallery
input NftGalleryCreateRequest {
  # The name of the NFT gallery
  name: String!

  # The NFTs in the gallery
  items: [NftInput!]!
}

# The NFT input for gallery
input NftInput {
  contract: NetworkAddressInput!

  # The token ID of the NFT
  tokenId: String!
}

# The input for updating NFT gallery name
input NftGalleryUpdateInfoRequest {
  # The NFT gallery id
  galleryId: NftGalleryId!

  # The name of the NFT gallery
  name: String!
}

# The input for reordering gallery items
input NftGalleryUpdateItemOrderRequest {
  # The NFT gallery id
  galleryId: NftGalleryId!

  # The order of the NFTs in the gallery
  updates: [NftUpdateItemOrder!]!
}

# The input for updating the order of a NFT gallery item
input NftUpdateItemOrder {
  # The contract address of the NFT
  EvmAddress: NetworkAddressInput!

  # The token ID of the NFT
  tokenId: String!

  # The new order of the NFT in the gallery
  newOrder: Int!
}

# The input for adding/removing gallery items
input NftGalleryUpdateItemsRequest {
  # The NFT gallery id
  galleryId: NftGalleryId!

  # The contents of the NFT gallery
  toAdd: [NftInput!] = []

  # The contents of the NFT gallery
  toRemove: [NftInput!] = []
}

# The input for deleting gallery
input NftGalleryDeleteRequest {
  # The NFT gallery id
  galleryId: NftGalleryId!
}

input CreateProfileRequest {
  handle: CreateHandle!

  # The profile picture uri
  profilePictureUri: Url

  # The follow module
  followModule: FollowModuleInput

  # The follow NFT URI is the NFT metadata your followers will mint when they follow you. This can be updated at all times. If you do not pass in anything it will create a super cool changing NFT which will show the last publication of your profile as the NFT which looks awesome! This means people do not have to worry about writing this logic but still have the ability to customise it for their followers
  followNFTURI: Url
}

# The request object to add interests to a profile
input AddProfileInterestsRequest {
  # The profile interest to add
  interests: [ProfileInterest!]!
}

enum CreateRelayErrorReasons {
  FAILED
  HANDLE_TAKEN
}

type CreateRelayError {
  reason: RelayErrorReasons!
}

union CreateRelayResult = RelaySuccess | CreateRelayError

# The request object to remove interests from a profile
input RemoveProfileInterestsRequest {
  # The profile interest to add
  interests: [ProfileInterest!]!
}

input DismissRecommendedProfilesRequest {
  for: [ProfileId!]!
}

# ProfileInterest custom scalar type
scalar ProfileInterest

type InternalPinResult {
  referenceItem: Url!
  ipfs: String!
}

input InternalPinRequest {
  # The shared secret
  items: [Url!]!

  # The shared secret
  secret: String!
}

# The nft type
type NFT {
  # aka us CryptoKitties
  contractName: String!

  # aka 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
  EvmAddress: EvmAddress!

  # aka RARI
  symbol: String!

  # aka "13"
  tokenId: String!

  # aka { address: 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e, amount:"2" }
  owners: Owner!

  # aka "Beard Coffee"
  name: String!

  # aka "Hey cutie! I m Beard Coffee. ....
  description: String!

  # aka "https://api.criptokitt..."
  contentURI: String!

  # aka "{ uri:"https://ipfs....", metaType:"image/png" }"
  originalContent: NFTContent!

  # aka "1"
  chainId: ChainId!

  # aka "CryptoKitties"
  collectionName: String!

  # aka "ERC721"
  ercType: String!
}

# The nft type
type Owner {
  # number of tokens owner
  amount: Int!

  # aka 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
  address: EvmAddress!
}

# The NFT content uri
type NFTContent {
  # The token uri  nft
  uri: String!

  # The meta type content
  metaType: String!

  # The animated url
  animationUrl: String
}

# Blockchain data scalar type
scalar BlockchainData

# UnixTimestamp custom scalar type
scalar UnixTimestamp

input ReferenceModuleInput {
  # The follower only reference module
  followerOnlyReferenceModule: Boolean

  # A unknown reference module
  unknownReferenceModule: UnknownReferenceModuleInput

  # TODO! MAP TOKEN GATED REFERENCE MODULE

  # The degrees of separation reference module
  degreesOfSeparationReferenceModule: DegreesOfSeparationReferenceModuleInput
}

input UnknownReferenceModuleInput {
  EvmAddress: EvmAddress!

  # The encoded data to submit with the module
  data: BlockchainData!
}

input DegreesOfSeparationReferenceModuleInput {
  # Applied to comments
  commentsRestricted: Boolean!

  # Applied to mirrors
  mirrorsRestricted: Boolean!

  # Applied to quotes
  quotesRestricted: Boolean!

  # Degrees of separation
  degreesOfSeparation: Int!
}

input SimpleCollectOpenActionModuleInput {
  # The collecting cost associated with this publication. 0 for free collect.
  amount: AmountInput!

  # The referral fee associated with this publication.
  referralFee: Float = 0

  recipient: EvmAddress!

  collectLimit: String

  followerOnly: Boolean!

  endsAt: DateTime
}

input OpenActionModuleInput {
  multirecipientCollectOpenAction: MultirecipientFeeCollectModuleInput

  simpleCollectOpenAction: SimpleCollectOpenActionModuleInput

  unknownOpenAction: UnknownCollectModuleInput
}

input MultirecipientFeeCollectModuleInput {
  # The collecting cost associated with this publication. 0 for free collect.
  amount: AmountInput!

  # The maximum number of collects for this publication. Omit for no limit.
  collectLimit: String

  # The referral fee associated with this publication.
  referralFee: Float = 0

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. Omit for no expiry.
  endsAt: DateTime

  # Recipient of collect fees.
  recipients: [RecipientDataInput!]!
}

input RecipientDataInput {
  # Recipient of collect fees.
  recipient: EvmAddress!

  # Split %, should be between 0.01 and 100. Up to 2 decimal points supported. All % should add up to 100
  split: Float!
}

input SimpleCollectModuleInput {
  # The collect module fee params
  fee: ModuleFeeInput

  # The collect module limit
  collectLimit: String

  # Collectible by followers only
  followerOnly: Boolean!

  # The timestamp that this collect module will expire
  endsAt: DateTime
}

input ModuleFeeInput {
  # The fee amount
  amount: AmountInput!

  # The fee recipient
  recipient: EvmAddress!

  # The referral fee
  referralFee: Float!
}

input UnknownCollectModuleInput {
  address: EvmAddress!

  # The encoded data to submit with the module
  data: BlockchainData!
}

# end types

# lens v2 through profile mutation:
# collect/act

input BlockRequest {
  # The profile to block
  profile: ProfileId!
}

input UnblockRequest {
  # The profile to block
  profile: ProfileId!
}

input CreateQuoteRequest {
  on: PublicationId!

  # The metadata uploaded somewhere passing in the url to reach it
  contentURI: Url!

  # The collect module
  openActionModule: [OpenActionModuleInput!]!

  # The reference module
  referenceModule: ReferenceModuleInput
}

type Mutation {
  # internal
  invite(request: InviteRequest!): Void
  ach(request: AchRequest!): Void
  hel(request: HelRequest!): Void
  gdi(request: GddRequest!): Void
  gci(request: GciRequest!): Void
  gcr(request: GcrRequest!): Void
  dss(request: PrfRequest!): Void
  nni(request: NniRequest!): Void
  nnv(request: NnvRequest!): Void
  in(request: InRequest!): Void
  claim(request: ClaimHandleRequest!): RelayResult!
  idKitPhoneVerifyWebhook(
    request: IdKitPhoneVerifyWebhookRequest!
  ): IdKitPhoneVerifyWebhookResultStatusType!
  # end internal

  # TODO! JOSH TO MAP OUT WHEN WRITES LOGIC
  #createBlockTypedData(options: TypedDataOptions, request: BlockRequest): CreateSetBlockBroadcastItemResult
  block(request: BlockRequest): LensProfileManagerRelayResult
  # TODO! JOSH TO MAP OUT WHEN WRITES LOGIC
  #createUnblockTypedData(options: TypedDataOptions, request: UnblockRequest): CreateSetUnblockBroadcastItemResult
  unblock(request: UnblockRequest): LensProfileManagerRelayResult

  # TODO! JOSH TO MAP OUT WHEN WRITES LOGIC
  #createQuoteTypedData(request: CreateQuoteRequest!): CreateQuoteBroadcastItemResult
  quote(request: CreateQuoteRequest!): LensProfileManagerRelayResult!

  authenticate(request: SignedAuthChallenge!): AuthenticationResult!
  refresh(request: RefreshRequest!): AuthenticationResult!
  broadcastMomoka(request: BroadcastRequest!): BroadcastMomokaResult!
  broadcast(request: BroadcastRequest!): RelayResult!

  createSetProfileManagerTypedData(
    options: TypedDataOptions
    request: SetProfileManagerRequest!
  ): CreateSetProfileManagerBroadcastItemResult!

  createFollowTypedData(
    options: TypedDataOptions
    request: FollowRequest!
  ): CreateFollowBroadcastItemResult!
  follow(request: FollowRequest!): LensProfileManagerRelayResult!

  createUnfollowTypedData(
    options: TypedDataOptions
    request: UnfollowRequest!
  ): CreateUnfollowBroadcastItemResult!
  unfollow(request: UnfollowRequest!): LensProfileManagerRelayResult!

  createSetFollowModuleTypedData(
    options: TypedDataOptions
    request: CreateSetFollowModuleRequest!
  ): CreateSetFollowModuleBroadcastItemResult!
  setFollowModule(request: CreateSetFollowModuleRequest!): LensProfileManagerRelayResult!

  createOpenActionActTypedData(
    options: TypedDataOptions
    request: CreateOpenActionActRequest!
  ): CreateOpenActionActBroadcastItemResult!
  openActionAct(request: CreateOpenActionActRequest!): LensProfileManagerRelayResult!

  createSetProfileMetadataTypedData(
    options: TypedDataOptions
    request: CreateSetProfileMetadataURIRequest!
  ): CreateSetProfileMetadataURIBroadcastItemResult!
  setProfileMetadata(request: CreateSetProfileMetadataURIRequest!): LensProfileManagerRelayResult!

  createSetProfileImageURITypedData(
    options: TypedDataOptions
    request: UpdateProfileImageRequest!
  ): CreateSetProfileImageUriBroadcastItemResult!
  createSetProfileImageURI(request: UpdateProfileImageRequest!): LensProfileManagerRelayResult!

  createDeleteProfileTypedData(
    options: TypedDataOptions
    request: DeleteProfileRequest!
  ): CreateDeleteProfileBroadcastItemResult!

  createMomokaPostTypedData(request: CreateMomokaPostRequest!): CreatePostBroadcastItemResult!
  createMomokaCommentTypedData(
    request: CreateMomokaCommentRequest!
  ): CreateCommentBroadcastItemResult!
  createMomokaMirrorTypedData(request: CreateMomokaMirrorRequest!): CreateMirrorBroadcastItemResult!
  createOnChainMirrorTypedData(
    options: TypedDataOptions
    request: CreateOnChainMirrorRequest!
  ): CreateMirrorBroadcastItemResult!

  createOnChainPostTypedData(
    options: TypedDataOptions
    request: CreateOnChainPostRequest!
  ): CreatePostBroadcastItemResult!
  postOnChain(request: CreateOnChainPostRequest!): LensProfileManagerRelayResult!
  postOnMomoka(request: CreateMomokaPostRequest!): RelayMomokaResult!
  createOnChainCommentTypedData(
    options: TypedDataOptions
    request: CreateOnChainCommentRequest!
  ): CreateCommentBroadcastItemResult!
  commentOnChain(request: CreateOnChainCommentRequest!): LensProfileManagerRelayResult!
  commentOnMomoka(request: CreateMomokaCommentRequest!): RelayMomokaResult!
  mirrorOnChain(request: CreateOnChainMirrorRequest!): LensProfileManagerRelayResult!
  mirrorOnMomoka(request: CreateMomokaMirrorRequest!): RelayMomokaResult!

  hidePublication(request: HidePublicationRequest!): Void
  addPublicationNotInterested(request: PublicationNotInterestedRequest!): Void
  undoPublicationNotInterested(request: PublicationNotInterestedRequest!): Void
  addPublicationBookmark(request: PublicationBookmarkRequest!): Void
  removePublicationBookmark(request: PublicationBookmarkRequest!): Void
  addReaction(request: ReactionRequest!): Void
  removeReaction(request: ReactionRequest!): Void
  reportPublication(request: ReportPublicationRequest!): Void
  nftOwnershipChallenge(request: NftOwnershipChallengeRequest!): NftOwnershipChallengeResult!
  createNftGallery(request: NftGalleryCreateRequest!): NftGalleryId!
  updateNftGalleryInfo(request: NftGalleryUpdateInfoRequest!): Void
  updateNftGalleryOrder(request: NftGalleryUpdateItemOrderRequest!): Void
  updateNftGalleryItems(request: NftGalleryUpdateItemsRequest!): Void
  deleteNftGallery(request: NftGalleryDeleteRequest!): Void
  createProfile(request: CreateProfileRequest!): CreateRelayResult!
  addProfileInterests(request: AddProfileInterestsRequest!): Void
  removeProfileInterests(request: RemoveProfileInterestsRequest!): Void
  dismissRecommendedProfiles(request: DismissRecommendedProfilesRequest!): Void
}

type Subscription {
  newMomokaTransaction: MomokaTransactionUnion!
  newPublicationStats(publicationIds: [PublicationId!]!): PublicationStats!
  newNotification(profileId: ProfileId!): Notification!
  watchLensTransaction(request: LensTransactionStatusRequest!): LensTransactionResult!
}
