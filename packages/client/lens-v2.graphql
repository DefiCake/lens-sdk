type Query {
  txIdToTxHash(txId: TxId!): TxHash!
  lensTransactionStatus(request: LensTransactionStatusRequest!): LensTransactionResult!
  nfts(request: NftsRequest!): PaginatedNftsResult!

  # Search for NFTs in a wallet by collection name. Supports Polygon and Ethereum and searches in both by default.
  searchNfts(request: NftSearchRequest!): PaginatedNftsResult!

  # Get the NFT collections that the given wallet or profileId owns at least one NFT of. Only supports Ethereum and Polygon NFTs. Note excludeFollowers is set to true by default, so the result will not include Lens Follower NFTsunless explicitly requested.
  nftCollections(request: NftCollectionsRequest!): PaginatedNftCollectionsResult!

  # Get the NFT collections that the given two profiles own at least one NFT of.
  mutualNftCollections(request: MutualNftCollectionsRequest!): PaginatedNftCollectionsResult!

  # Get the Lens Profiles that own NFTs from a given collection.
  nftCollectionOwners(request: NftCollectionOwnersRequest!): PaginatedProfileResult!

  # Get the most popular NFT collections. Popularity is based on how many Lens Profiles own NFTs from a given collection.
  popularNftCollections(
    request: PopularNftCollectionsRequest!
  ): PaginatedPopularNftCollectionsResult!
  nftGalleries(request: NftGalleriesRequest!): [NftGallery!]!
  linkHandleToProfile(request: LinkHandleRequest!): Void
  unlinkHandleFromProfile(request: UnlinkHandleRequest!): Void
  ownedHandles(request: OwnedHandlesRequest!): PaginatedHandlesResult!
  relayQueues: [RelayQueueResult!]!
  momokaSubmitters: MomokaSubmittersResult!
  momokaSummary: MomokaSummaryResult!
  momokaTransactions(request: MomokaTransactionsRequest!): MomokaTransactionsResult!
  momokaTransaction(request: MomokaTransactionRequest!): MomokaTransaction!
  publications(request: PublicationsRequest!): PaginatedPublicationsResult!
  publication(request: PublicationRequest!): AnyPublication
  publicationsTags(request: PublicationsTagsRequest!): PaginatedPublicationsTagsResult!
  profileBookmarks(request: ProfileBookmarksRequest!): PaginatedPublicationsResult!
  whoReactedPublication(request: WhoReactedPublicationRequest!): PaginatedWhoReactedResult!
  explorePublications(request: ExplorePublicationRequest!): PaginatedExplorePublicationResult!
  validatePublicationMetadata(
    request: ValidatePublicationMetadataRequest!
  ): PublicationValidateMetadataResult!
  forYou(request: PublicationForYouRequest!): PaginatedForYouResult!
  revenueFromPublications(
    request: RevenueFromPublicationsRequest!
  ): PaginatedRevenueFromPublicationsResult!
  revenueForPublication(request: PublicationRevenueRequest!): PublicationRevenue!
  searchPublications(request: PublicationSearchRequest!): PaginatedPublicationPrimaryResult!
  approvedModuleAllowanceAmount(
    request: ApprovedModuleAllowanceAmountRequest!
  ): ApprovedAllowanceAmountResult!
  generateModuleCurrencyApprovalData(
    request: GenerateModuleCurrencyApprovalDataRequest!
  ): GenerateModuleCurrencyApprovalResult!
  supportedModules: [SupportedModules!]!
  profiles(request: ProfilesRequest!): PaginatedProfileResult!
  profile(request: ProfileRequest!): Profile
  whoActedOnPublication(request: WhoActedOnPublicationRequest!): PaginatedProfileResult
  profileInterestsOptions: [String!]!
  claimableProfiles: ClaimableProfilesResult!
  claimableStatus: ClaimProfileStatusType!
  exploreProfiles(request: ExploreProfilesRequest!): PaginatedProfileResult!
  invitedProfiles: [InvitedResult!]!
  profileAlreadyInvited(request: AlreadyInvitedCheckRequest!): Boolean!
  profileManagers(request: ProfileManagersRequest!): PaginatedProfileManagersResult!
  profilesManaged(request: ProfilesManagedRequest!): PaginatedProfileResult!
  profileRecommendations(request: ProfileRecommendationsRequest!): PaginatedProfileResult!
  followRevenues(request: FollowRevenueRequest!): FollowRevenueResult!
  searchProfiles(request: ProfileSearchRequest!): PaginatedProfileResult!
  challenge(request: ChallengeRequest!): AuthChallengeResult!
  verify(request: VerifyRequest!): Boolean!
  feed(request: FeedRequest!): PaginatedFeedResult!
  feedHighlights(request: FeedHighlightsRequest!): PaginatedFeedHighlightsResult!
  notifications(request: NotificationRequest!): PaginatedNotificationResult!
  poaps(request: UserPoapsQueryRequest!): PaginatedPoapResult!
  mutualPoaps(request: MutualPoapsQueryRequest!): PaginatedPoapResult!
  poapHolders(request: PoapHoldersQueryRequest!): PaginatedPoapResult!
  currencies: [Erc20!]!
  followers(request: FollowersRequest!): PaginatedProfileResult!
  mutualFollowers(request: MutualFollowersRequest!): PaginatedProfileResult!
  following(request: FollowingRequest!): PaginatedProfileResult!
  ping: String!
  rel(request: RelRequest!): Void
  cur(request: CurRequest!): [String!]!
  gdm(request: GdmRequest!): [URL!]!
  gct(request: GctRequest!): [String!]!
  iss(request: PriRequest!): [PrfResult!]!
  intotal(request: InTotalRequest!): Int!
  userSigNonces: UserSigNonces!
}

# The tx hash
scalar TxHash

# The tx id
scalar TxId

union LensTransactionResult = LensTransaction | LensMetadataTransaction

type LensTransaction {
  status: LensTransactionStatusType!
  txHash: TxHash!
  reason: LensTransactionFailureType
  extraInfo: String
}

enum LensTransactionStatusType {
  PROGRESSING
  COMPLETE
  FAILED
}

enum LensTransactionFailureType {
  REVERTED
}

type LensMetadataTransaction {
  status: LensTransactionStatusType!
  metadataFailedReason: LensMetadataTransactionFailureType
  extraInfo: String
}

enum LensMetadataTransactionFailureType {
  REVERTED
  METADATA_ERROR
}

input LensTransactionStatusRequest {
  # Transaction hash for retrieving transaction status
  txHash: TxHash

  # Transaction ID for retrieving transaction status when using the broadcaster
  txId: TxId
}

type PaginatedNftsResult {
  items: [Nft!]!
  pageInfo: PaginatedResultInfo!
}

type Nft {
  tokenId: TokenId!
  ownerInfo: Owner!
  contentUri: URI!
  contract: NetworkAddress!
  contractType: NftContractType!
  collection: NftCollection!
  metadata: NftMetadata!
}

# The NFT token id
scalar TokenId

type Owner {
  amount: Int!
  address: EvmAddress!
}

# evm address type
scalar EvmAddress

# The URI value not this can be used in it can be a https OR different aka ar:// and ipfs://
scalar URI

type NetworkAddress {
  address: EvmAddress!
  chainId: ChainId!
}

# The chain id
scalar ChainId

enum NftContractType {
  ERC721
  ERC1155
  ERC721Enumerable
}

# Nft Collection type
type NftCollection {
  # The contract info, address and chain id
  contract: NetworkAddress!

  # Collection name
  name: String!

  # Collection symbol
  symbol: String!

  # Collection base URI for token metadata
  baseUri: URI

  # Collection ERC type
  contractType: NftContractType!
}

type NftMetadata {
  name: String!
  description: String!
  image: URI!
}

# The paginated result info
type PaginatedResultInfo {
  # Cursor to query the actual results
  prev: Cursor

  # Cursor to query next results
  next: Cursor
}

# Cursor custom scalar type
scalar Cursor

input NftsRequest {
  limit: LimitScalar
  cursor: Cursor
  where: NftsRequestWhere
}

# The limit number
scalar LimitScalar

input NftsRequestWhere {
  for: ProfileId
  query: String
  includeCollections: [NetworkAddressInput!] = []
  excludeCollections: [NetworkAddressInput!] = []
  chainIds: [ChainId!] = []
}

# ProfileId custom scalar type
scalar ProfileId

input NetworkAddressInput {
  address: EvmAddress!
  chainId: ChainId!
}

# NFT search query
input NftSearchRequest {
  limit: LimitScalar
  cursor: Cursor

  # Search query. Has to be part of a collection name
  query: String!

  # Profile ID of the owner
  forProfileId: ProfileId = null

  # Ethereum address of the owner. If unknown you can also search by profile ID
  forAddress: EvmAddress = null

  # Chain IDs to search. Supports Ethereum and Polygon. If omitted, it will search in both chains
  chainIds: [ChainId!] = [5, 80001]

  # Exclude follower NFTs from the search
  excludeFollowers: Boolean = true
}

# Nft collections paginated result
type PaginatedNftCollectionsResult {
  items: [NftCollection!]!
  pageInfo: PaginatedResultInfo!
}

# NFT collections request
input NftCollectionsRequest {
  limit: Float = 50
  cursor: Cursor

  # Filter by owner address
  forAddress: EvmAddress
  for: ProfileId

  # The chain ids to look for NFTs on. Ethereum and Polygon are supported. If omitted, it will look on both chains by default.
  chainIds: [ChainId!] = [5, 80001]

  # Exclude Lens Follower NFTs
  excludeFollowers: Boolean = true
}

# Mutual NFT collections request
input MutualNftCollectionsRequest {
  limit: LimitScalar
  cursor: Cursor

  # Profile id of the first user
  yourProfileId: ProfileId!

  # Profile id of the second user
  viewingProfileId: ProfileId!
}

# The paginated profile result
type PaginatedProfileResult {
  items: [Profile!]!
  pageInfo: PaginatedResultInfo!
}

# The Profile
type Profile {
  # The profile id
  id: ProfileId!

  # Who owns the profile
  ownedBy: NetworkAddress!

  # The gasless settings for the profile
  gasless: Gasless!
  txHash: TxHash!

  # When the profile was created
  createdAt: DateTime!
  stats(request: ProfileStatsArgs!): ProfileStats!
  interests: [String!]!
  isFollowedByMe: OptimisticStatusResult!
  isFollowingMe: OptimisticStatusResult!
  guardian: ProfileGuardianResult
  invitedBy: Profile

  # The number of invites left
  invitesLeft: Int

  # The on chain identity
  onChainIdentity: ProfileOnChainIdentity!

  # The profile follow nft address
  followNftAddress: NetworkAddress

  # The profile metadata
  metadata: ProfileMetadata

  # The follow module
  followModule: FollowModule

  # The profile handle - a profile may not have one
  handle: Handle
}

type Gasless {
  enabled: Boolean!
  relay: NetworkAddress
}

# The javascript `Date` as string. Type represents date and time as the ISO Date string.
scalar DateTime

# The Profile Stats
type ProfileStats {
  id: ProfileId!
  followers(request: ProfileStatsArgs!): Int!
  following(request: ProfileStatsArgs!): Int!
  comments(request: ProfileStatsArgs!): Int!
  posts(request: ProfileStatsArgs!): Int!
  mirrors(request: ProfileStatsArgs!): Int!
  quotes(request: ProfileStatsArgs!): Int!
  publications(request: ProfileStatsArgs!): Int!
  reactions(request: ProfileStatsReactionArgs!): Int!
  countOpenActions(request: ProfileStatsCountOpenActionArgs!): Int!
}

input ProfileStatsArgs {
  forApps: [AppId!] = []
  customFilters: [CustomFiltersType!] = []
}

# The app id
scalar AppId

enum CustomFiltersType {
  GARDENERS
}

input ProfileStatsReactionArgs {
  type: PublicationReactionType
}

enum PublicationReactionType {
  UPVOTE
  DOWNVOTE
}

input ProfileStatsCountOpenActionArgs {
  anyOf: [OpenActionFilter!]
}

input OpenActionFilter {
  address: EvmAddress
  type: OpenActionModuleType
  category: OpenActionCategoryType
}

enum OpenActionModuleType {
  SimpleCollectOpenActionModule
  MultirecipientFeeCollectOpenActionModule
  UnknownOpenActionModule
  LegacyLimitedFeeCollectModule
  LegacyFeeCollectModule
  LegacyLimitedTimedFeeCollectModule
  LegacyTimedFeeCollectModule
  LegacyAaveFeeCollectModule
  LegacyRevertCollectModule
  LegacyFreeCollectModule
  LegacyMultirecipientFeeCollectModule
  LegacyERC4626FeeCollectModule
  LegacySimpleCollectModule
}

enum OpenActionCategoryType {
  COLLECT
}

type OptimisticStatusResult {
  value: Boolean!
  isFinalisedOnChain: Boolean!
}

type ProfileGuardianResult {
  protected: Boolean!
  cooldownEndsOn: DateTime
}

type ProfileOnChainIdentity {
  # The POH status
  proofOfHumanity: Boolean!

  # The ens information
  ens: EnsOnChainIdentity

  # The sybil dot org information
  sybilDotOrg: SybilDotOrgIdentity!

  # The worldcoin identity
  worldcoin: WorldcoinIdentity!
}

type EnsOnChainIdentity {
  # The default ens mapped to this address
  name: Ens
}

# The ens name
scalar Ens

type SybilDotOrgIdentity {
  # The sybil dot org status
  verified: Boolean!
  source: SybilDotOrgIdentitySource!
}

type SybilDotOrgIdentitySource {
  twitter: SybilDotOrgTwitterIdentity!
}

type SybilDotOrgTwitterIdentity {
  handle: String
}

type WorldcoinIdentity {
  # If the profile has verified as a user
  isHuman: Boolean!
}

type ProfileMetadata {
  # The raw uri for the which the profile metadata was set as
  rawURI: URI!

  # The display name for the profile
  displayName: String

  # The bio for the profile
  bio: String

  # The cover picture for the profile
  coverPicture: ImageSet

  # The picture for the profile
  picture: ProfilePicture

  # Optionals param to add extra attributes on the metadata
  attributes: [Attribute!]
}

type ImageSet {
  rawURI: URI!
  image: Image!

  # Alternative text for the image
  altTag: String
  transformed(request: ImageTransform!): Image!
}

type Image {
  url: URI!

  # MIME type of the image
  mimeType: ImageMimeType

  # Width of the image
  width: Int

  # Height of the image
  height: Int
}

enum ImageMimeType {
  PNG
}

input ImageTransform {
  # Set the transformed image's width
  width: ImageSizeTransform

  # Set the transformed image's height
  height: ImageSizeTransform

  # Set if you want to keep the image's original aspect ratio. True by default. If explicitly set to false, the image will stretch based on the width and height values.
  keepAspectRatio: Boolean = true
}

# The image size transform
scalar ImageSizeTransform

union ProfilePicture = ImageSet | NftImage

type NftImage {
  # The contract address of the NFT collection
  collection: NetworkAddress!

  # The token ID of the NFT
  tokenId: TokenId!

  # The image set for the NFT
  image: ImageSet!

  # Indicates whether the NFT is verified or not
  verified: Boolean!
}

type Attribute {
  # The type of the attribute
  type: AttributeType!

  # Identifier of this attribute, used for updating
  key: String!

  # Value of the attribute
  value: String!
}

enum AttributeType {
  BOOLEAN
  DATE
  NUMBER
  STRING
  JSON
}

union FollowModule =
    FeeFollowModuleSettings
  | ProfileFollowModuleSettings
  | RevertFollowModuleSettings
  | UnknownFollowModuleSettings

type FeeFollowModuleSettings {
  contract: NetworkAddress!

  # The amount info
  amount: Amount!

  # The module recipient address
  recipient: EvmAddress!
}

type Amount {
  # The asset
  asset: Asset!

  # Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal.
  value: String!
  rate(request: String!): FiatAmount!
}

union Asset = Erc20

# The erc20 type
type Erc20 {
  # Name of the symbol
  name: String!

  # Symbol for the token
  symbol: String!

  # Decimal places for the token
  decimals: Int!

  # The erc20 address
  contract: NetworkAddress!
}

type FiatAmount {
  asset: Fiat!
  value: String!
}

type Fiat {
  name: String!
  symbol: String!
  decimals: Int!
}

type ProfileFollowModuleSettings {
  contract: NetworkAddress!
}

type RevertFollowModuleSettings {
  contract: NetworkAddress!
}

type UnknownFollowModuleSettings {
  contract: NetworkAddress!

  # The data used to setup the module which you can decode with your known ABI
  followModuleReturnData: BlockchainData!
}

# Blockchain data
scalar BlockchainData

# The handle attached to a profile - note its it own NFT
scalar Handle

# NFT collection owners request
input NftCollectionOwnersRequest {
  limit: LimitScalar
  cursor: Cursor

  # The contract address
  address: EvmAddress!

  # The chain id
  chainId: ChainId!

  # The ordering of Nft collection owners
  order: NftCollectionOwnersOrder = None

  # The profile id to use when ordering by followers
  for: ProfileId = null
}

enum NftCollectionOwnersOrder {
  FollowersFirst
  None
}

# Popular Nft collections paginated result
type PaginatedPopularNftCollectionsResult {
  items: [NftCollectionWithOwners!]!
  pageInfo: PaginatedResultInfo!
}

# A wrapper object containing an Nft collection, the total number of Lens profiles that own it, and optional field resolvers
type NftCollectionWithOwners {
  # The Nft collection
  collection: NftCollection!

  # The total number of Lens profiles that own this collection
  totalProfiles: Float!
}

# Popular NFT collections request
input PopularNftCollectionsRequest {
  limit: LimitScalar
  cursor: Cursor

  # The chain ids to look for NFTs on. Ethereum and Polygon are supported. If omitted, it will look on both chains by default.
  chainIds: [ChainId!] = [5, 80001]

  # Exclude Lens Follower NFTs
  excludeFollowers: Boolean = true

  # Include only verified collections
  onlyVerified: Boolean = true
}

type NftGallery {
  id: NftGalleryId!
  name: NftGalleryName!
  owner: ProfileId!
  items: [Nft!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

# Nft gallery id type
scalar NftGalleryId

# Nft gallery name type
scalar NftGalleryName

input NftGalleriesRequest {
  for: ProfileId!
}

# Represents NULL values
scalar Void

input LinkHandleRequest {
  handle: Handle!
}

input UnlinkHandleRequest {
  handle: Handle!
}

type PaginatedHandlesResult {
  items: [HandleResult!]!
  pageInfo: PaginatedResultInfo!
}

type HandleResult {
  handle: Handle!
}

input OwnedHandlesRequest {
  # The Ethereum address for which to retrieve owned handles
  address: EvmAddress!
}

type RelayQueueResult {
  key: RelayRoleKey!
  relay: NetworkAddress!
  queue: Int!
}

enum RelayRoleKey {
  CREATE_PROFILE
  DISPATCHER_1
  DISPATCHER_2
  DISPATCHER_3
  DISPATCHER_4
  DISPATCHER_5
  DISPATCHER_6
  DISPATCHER_7
  DISPATCHER_8
  DISPATCHER_9
  DISPATCHER_10
  PROXY_ACTION_COLLECT_1
  PROXY_ACTION_COLLECT_2
  PROXY_ACTION_COLLECT_3
  PROXY_ACTION_COLLECT_4
  PROXY_ACTION_COLLECT_5
  PROXY_ACTION_COLLECT_6
  PROXY_ACTION_FOLLOW_1
  PROXY_ACTION_FOLLOW_2
  PROXY_ACTION_FOLLOW_3
  PROXY_ACTION_FOLLOW_4
  PROXY_ACTION_FOLLOW_5
  PROXY_ACTION_FOLLOW_6
  PROXY_ACTION_FOLLOW_7
  PROXY_ACTION_FOLLOW_8
  PROXY_ACTION_FOLLOW_9
  PROXY_ACTION_FOLLOW_10
  WITH_SIG_1
  WITH_SIG_2
  WITH_SIG_3
  ZK_RELAYER_1
}

type MomokaSubmittersResult {
  items: [MomokaSubmitterResult!]!
  pageInfo: PaginatedResultInfo!
}

type MomokaSubmitterResult {
  address: EvmAddress!
  name: String!
  totalTransactions: Int!
}

type MomokaSummaryResult {
  totalTransactions: Int!
}

type MomokaTransactionsResult {
  items: [MomokaTransaction!]!
  pageInfo: PaginatedResultInfo!
}

union MomokaTransaction =
    MomokaPostTransaction
  | MomokaCommentTransaction
  | MomokaMirrorTransaction
  | MomokaQuoteTransaction

type MomokaPostTransaction {
  transactionId: String!
  submitter: EvmAddress!
  createdAt: DateTime!
  app: App!
  verificationStatus: MomokaVerificationStatus!
  profile: Profile!
  publicationId: PublicationId!
}

type App {
  id: AppId!
}

union MomokaVerificationStatus = MomokaVerificationStatusSuccess | MomokaVerificationStatusFailure

type MomokaVerificationStatusSuccess {
  verified: Boolean!
}

type MomokaVerificationStatusFailure {
  status: MomokaValidatorErrorType!
}

enum MomokaValidatorErrorType {
  NO_SIGNATURE_SUBMITTER
  INVALID_SIGNATURE_SUBMITTER
  TIMESTAMP_PROOF_INVALID_SIGNATURE
  TIMESTAMP_PROOF_INVALID_TYPE
  TIMESTAMP_PROOF_INVALID_DA_ID
  TIMESTAMP_PROOF_NOT_SUBMITTER
  CAN_NOT_CONNECT_TO_BUNDLR
  INVALID_TX_ID
  INVALID_FORMATTED_TYPED_DATA
  BLOCK_CANT_BE_READ_FROM_NODE
  DATA_CANT_BE_READ_FROM_NODE
  SIMULATION_NODE_COULD_NOT_RUN
  SIMULATION_FAILED
  EVENT_MISMATCH
  INVALID_EVENT_TIMESTAMP
  INVALID_TYPED_DATA_DEADLINE_TIMESTAMP
  GENERATED_PUBLICATION_ID_MISMATCH
  INVALID_POINTER_SET_NOT_NEEDED
  POINTER_FAILED_VERIFICATION
  NOT_CLOSEST_BLOCK
  BLOCK_TOO_FAR
  PUBLICATION_NO_POINTER
  PUBLICATION_NONE_DA
  PUBLICATION_NONCE_INVALID
  PUBLICATION_SIGNER_NOT_ALLOWED
  CHAIN_SIGNATURE_ALREADY_USED
  POTENTIAL_REORG
  UNKNOWN
}

# Publication id
scalar PublicationId

type MomokaCommentTransaction {
  transactionId: String!
  submitter: EvmAddress!
  createdAt: DateTime!
  app: App!
  verificationStatus: MomokaVerificationStatus!
  profile: Profile!
  publicationId: PublicationId!
  commentedOnProfile: Profile!
  commentedOnPublicationId: PublicationId!
}

type MomokaMirrorTransaction {
  transactionId: String!
  submitter: EvmAddress!
  createdAt: DateTime!
  app: App!
  verificationStatus: MomokaVerificationStatus!
  profile: Profile!
  publicationId: PublicationId!
  mirrorOfProfile: Profile!
  mirrorOfPublicationId: PublicationId!
}

type MomokaQuoteTransaction {
  transactionId: String!
  submitter: EvmAddress!
  createdAt: DateTime!
  app: App!
  verificationStatus: MomokaVerificationStatus!
  profile: Profile!
  publicationId: PublicationId!
  quotedOnProfile: Profile!
  quotedOnPublicationId: PublicationId!
}

input MomokaTransactionsRequest {
  limit: LimitScalar
  cursor: Cursor
  for: ProfileId!
}

input MomokaTransactionRequest {
  # The momoka transaction id or internal publication id
  id: String!
}

type PaginatedPublicationsResult {
  items: [AnyPublication!]!
  pageInfo: PaginatedResultInfo!
}

union AnyPublication = Post | Comment | Mirror | Quote

type Post {
  id: PublicationId!
  by: Profile!
  publishedOn: App
  isHidden: Boolean!
  isGated: Boolean!
  momoka: MomokaInfo
  txHash: TxHash!
  createdAt: DateTime!
  stats(request: PublicationStatsInput!): PublicationStats!
  operations: PublicationOperations!
  metadata: PublicationMetadata!
  openActionModules: [OpenActionModule!]
  referenceModule: ReferenceModule
}

type MomokaInfo {
  proof: MomokaProof!
}

# The momoke proof
scalar MomokaProof

type PublicationStats {
  additionalArgs: PublicationStatsRequest!
  id: PublicationId!
  comments: Int!
  mirrors: Int!
  quotes: Int!
  reactions(request: PublicationStatsReactionArgs!): Int!
  countOpenActions(request: PublicationStatsCountOpenActionArgs!): Int!
}

type PublicationStatsRequest {
  forApps: [AppId!]
  customFilters: [CustomFiltersType!]
}

input PublicationStatsReactionArgs {
  type: PublicationReactionType
}

input PublicationStatsCountOpenActionArgs {
  anyOf: [OpenActionFilter!]
}

input PublicationStatsInput {
  forApps: [AppId!] = []
  customFilters: [CustomFiltersType!] = []
}

type PublicationOperations {
  id: PublicationId!
  isNotInterested: Boolean!
  hasBookmarked: Boolean!
  hasReported: Boolean!
  hasActed: [OpenActionResult!]!
  hasReacted(request: PublicationOperationsReactionArgs!): Boolean!
  canComment: Boolean!
  canMirror: Boolean!
  hasMirrored: Boolean!
  canDecrypt: CanDecryptResponse!
}

union OpenActionResult = CollectOpenActionResult | UnknownOpenActionResult

type CollectOpenActionResult {
  type: CollectOpenActionModuleType!
}

enum CollectOpenActionModuleType {
  LegacyLimitedFeeCollectModule
  LegacyFeeCollectModule
  LegacyLimitedTimedFeeCollectModule
  LegacyTimedFeeCollectModule
  LegacyAaveFeeCollectModule
  LegacyRevertCollectModule
  LegacyFreeCollectModule
  LegacyMultirecipientFeeCollectModule
  LegacyERC4626FeeCollectModule
  LegacySimpleCollectModule
  UnknownOpenActionModule
}

type UnknownOpenActionResult {
  address: EvmAddress!
  redeemData: BlockchainData!
}

input PublicationOperationsReactionArgs {
  type: PublicationReactionType
}

type CanDecryptResponse {
  result: Boolean!
  reasons: [DecryptFailReasonType!]
  extraDetails: String
}

enum DecryptFailReasonType {
  UNAUTHORIZED_ADDRESS
  DOES_NOT_OWN_NFT
  DOES_NOT_OWN_PROFILE
  DOES_NOT_FOLLOW_PROFILE
  HAS_NOT_COLLECTED_PUBLICATION
  UNAUTHORIZED_BALANCE
  PROFILE_DOES_NOT_EXIST
  MISSING_ENCRYPTION_PARAMS
  FOLLOW_NOT_FINALISED_ON_CHAIN
  COLLECT_NOT_FINALISED_ON_CHAIN
  CAN_NOT_DECRYPT
}

union PublicationMetadata =
    PublicationMetadataV2
  | PublicationVideoMetadataV1
  | PublicationImageMetadataV1
  | ArticleMetadataV1
  | EventMetadataV1
  | LinkMetadataV1
  | EmbedMetadataV1
  | CheckingInMetadataV1
  | TextOnlyMetadataV1
  | ThreeDMetadataV1
  | StoryMetadataV1
  | TransactionMetadataV1
  | MintMetadataV1
  | SpaceMetadataV1
  | LiveStreamMetadataV1
  | FutureProofPublicationMetadata

type PublicationMetadataV2 {
  name: Markdown
  description: Markdown
  content: Markdown
  image: ImageSet
  media: [MediaSet!]
  attributes: [PublicationMarketplaceMetadataAttribute!]
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  mainContentFocus: PublicationMetadataV2MainFocusType!
  animationUrl: URI
  encryptedWith: PublicationMetadataV2Encryption
}

# The markdown value
scalar Markdown

union MediaSet = VideoSet | AudioSet | ImageSet

type VideoSet {
  rawURI: URI!
  video: Video!
  altTag: String
}

type Video {
  url: URI!
  mimeType: VideoMimeType
}

enum VideoMimeType {
  MP4
}

type AudioSet {
  rawURI: URI!
  audio: Audio!
}

type Audio {
  url: URI!
  mimeType: AudioMimeType
}

enum AudioMimeType {
  MP3
}

type PublicationMarketplaceMetadataAttribute {
  displayType: PublicationMarketplaceMetadataAttributeDisplayType
  traitType: String
  value: String
}

enum PublicationMarketplaceMetadataAttributeDisplayType {
  NUMBER
  STRING
  DATE
}

# The locale
scalar Locale

enum PublicationContentWarningType {
  NSFW
  SENSITIVE
  SPOILER
}

enum PublicationMetadataV2MainFocusType {
  VIDEO
  IMAGE
  ARTICLE
  TEXT_ONLY
  AUDIO
  LINK
  EMBED
}

type PublicationMetadataV2Encryption {
  encryptionKey: ContentEncryptionKey!
  accessCondition: AccessCondition!
  encryptedFields: PublicationMetadataV2EncryptedFields!
}

# The content encryption key value
scalar ContentEncryptionKey

union AccessCondition =
    NftOwnershipCondition
  | Erc20OwnershipCondition
  | EoaOwnershipCondition
  | ProfileOwnershipCondition
  | FollowCondition
  | CollectCondition
  | AndCondition
  | OrCondition

type NftOwnershipCondition {
  contract: NetworkAddress!
  contractType: NftContractType!
  tokenIds: [TokenId!]
}

type Erc20OwnershipCondition {
  contract: NetworkAddress!
  amount: Amount!
  condition: ComparisonOperatorConditionType!
}

enum ComparisonOperatorConditionType {
  EQUAL
  NOT_EQUAL
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN
  LESS_THAN_OR_EQUAL
}

type EoaOwnershipCondition {
  address: EvmAddress!
}

type ProfileOwnershipCondition {
  profileId: ProfileId!
}

type FollowCondition {
  follow: ProfileId!
}

type CollectCondition {
  publicationId: PublicationId
  thisPublication: Boolean
}

type AndCondition {
  criteria: [AccessCondition!]!
}

type OrCondition {
  criteria: [AccessCondition!]!
}

type PublicationMetadataV2EncryptedFields {
  content: EncryptedValue
  image: EncryptedValue
  media: [EncryptedMedia!]
  animationUrl: EncryptedValue
  externalUrl: EncryptedValue
}

# The encrypted value
scalar EncryptedValue

type EncryptedMedia {
  uri: URI!
  mimeType: MimeType
  altTag: EncryptedValue
  cover: EncryptedValue
}

# Mimetype type
scalar MimeType

type PublicationVideoMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  video: PublicationMetadataMediaVideo!
  mainContentFocus: PublicationVideoMetadataV1MainFocusType!
  attachments: [PublicationMetadataAttachment!]
}

type MarketplaceMetadata {
  description: Markdown
  externalURL: URL
  name: String!
  attributes: [PublicationMarketplaceMetadataAttribute!]
  image: URI
  animationUrl: URI
}

# The url value
scalar URL

type PublicationMetadataV3Attribute {
  key: String!
  value: String!
}

union PublicationMetadataEncryptionStrategy =
    PublicationMetadataV3LitEncryption
  | FutureProofPublicationEncryptionStrategy

type PublicationMetadataV3LitEncryption {
  encryptionKey: ContentEncryptionKey!
  accessCondition: AccessCondition!
}

type FutureProofPublicationEncryptionStrategy {
  id: String
}

type PublicationMetadataMediaVideo {
  type: VideoMimeType!
  item: VideoSet!
  cover: ImageSet
  duration: Int
  license: PublicationMetadataLicenseType
}

enum PublicationMetadataLicenseType {
  ALL_RIGHTS_RESERVED
}

enum PublicationVideoMetadataV1MainFocusType {
  VIDEO
  SHORT_VIDEO
}

union PublicationMetadataAttachment =
    PublicationMetadataMediaVideo
  | PublicationMetadataMediaImage
  | PublicationMetadataMediaAudio

type PublicationMetadataMediaImage {
  type: ImageMimeType!
  item: ImageSet!
  license: PublicationMetadataLicenseType
}

type PublicationMetadataMediaAudio {
  type: AudioMimeType!
  item: AudioSet!
  cover: ImageSet
  duration: Int
  license: PublicationMetadataLicenseType
  credits: String
  artist: String
  genre: String
  recordLabel: String
  audioType: PublicationMetadataMediaAudioType
  lyrics: String
}

enum PublicationMetadataMediaAudioType {
  MP3
}

type PublicationImageMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  mainContentFocus: PublicationImageMetadataV1MainFocusType!
  image: PublicationMetadataMediaImage!
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationImageMetadataV1MainFocusType {
  IMAGE
}

type ArticleMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown!
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  mainContentFocus: PublicationArticleMetadataV1MainFocusType!
  title: String
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationArticleMetadataV1MainFocusType {
  ARTICLE
}

type EventMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  mainContentFocus: PublicationEventMetadataV1MainFocusType!
  geographic: GeoLocation
  startsAt: DateTime!
  endsAt: DateTime!
  links: [URL!]
  location: String!
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationEventMetadataV1MainFocusType {
  EVENT
}

type GeoLocation {
  latitude: Float
  longitude: Float
}

type LinkMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  mainContentFocus: PublicationLinkMetadataV1MainFocusType!
  sharingLink: URL!
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationLinkMetadataV1MainFocusType {
  LINK
}

type EmbedMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  mainContentFocus: PublicationEmbedMetadataV1MainFocusType!
  embed: URL!
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationEmbedMetadataV1MainFocusType {
  EMBED
}

type CheckingInMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  location: String!
  geographic: GeoLocation
  mainContentFocus: PublicationCheckingInMetadataV1MainFocusType!
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationCheckingInMetadataV1MainFocusType {
  CHECKING_IN
}

type TextOnlyMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown!
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  mainContentFocus: PublicationTextOnlyMetadataV1MainFocusType!
}

enum PublicationTextOnlyMetadataV1MainFocusType {
  TEXT_ONLY
}

type ThreeDMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  assets: [ThreeDMetadataV1Asset!]!
  mainContentFocus: PublicationThreeDMetadataV1MainFocusType!
  attachments: [PublicationMetadataAttachment!]
}

type ThreeDMetadataV1Asset {
  uri: URI!
  zipPath: String
  playerURL: URL!
  format: String!
  license: PublicationMetadataLicenseType
}

enum PublicationThreeDMetadataV1MainFocusType {
  THREE_D
}

type StoryMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  mainContentFocus: PublicationStoryMetadataV1MainFocusType!
  asset: PublicationMetadataAttachment!
}

enum PublicationStoryMetadataV1MainFocusType {
  STORY
}

type TransactionMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  type: PublicationTransactionMetadataType!
  txHash: TxHash!
  chainId: ChainId!
  mainContentFocus: PublicationTransactionMetadataV1MainFocusType!
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationTransactionMetadataType {
  ERC721
  ERC20
  OTHER
}

enum PublicationTransactionMetadataV1MainFocusType {
  TRANSACTION
}

type MintMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  mintLink: URL!
  mainContentFocus: PublicationMintMetadataV1MainFocusType!
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationMintMetadataV1MainFocusType {
  MINT
}

type SpaceMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  title: String!
  link: URL!
  startsAt: DateTime!
  mainContentFocus: PublicationSpaceMetadataV1MainFocusType!
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationSpaceMetadataV1MainFocusType {
  SPACE
}

type LiveStreamMetadataV1 {
  id: String!
  rawURI: URI!
  content: Markdown
  locale: Locale
  tags: [String!]
  contentWarning: PublicationContentWarningType
  hideFromFeed: Boolean!
  globalReach: Boolean!
  appId: AppId
  marketplace: MarketplaceMetadata
  attributes: [PublicationMetadataV3Attribute!]
  encryptedWith: PublicationMetadataEncryptionStrategy
  title: String
  startsAt: DateTime!
  endsAt: DateTime
  playbackURL: URL!
  liveURL: URL!
  checkLiveAPI: URL
  mainContentFocus: PublicationLiveStreamMetadataV1MainFocusType!
  attachments: [PublicationMetadataAttachment!]
}

enum PublicationLiveStreamMetadataV1MainFocusType {
  LIVESTREAM
}

type FutureProofPublicationMetadata {
  id: String!
}

union OpenActionModule =
    SimpleCollectOpenActionSettings
  | MultirecipientFeeCollectOpenActionSettings
  | LegacyFreeCollectModuleSettings
  | LegacyFeeCollectModuleSettings
  | LegacyLimitedFeeCollectModuleSettings
  | LegacyLimitedTimedFeeCollectModuleSettings
  | LegacyRevertCollectModuleSettings
  | LegacyTimedFeeCollectModuleSettings
  | LegacyMultirecipientFeeCollectModuleSettings
  | LegacySimpleCollectModuleSettings
  | LegacyERC4626FeeCollectModuleSettings
  | LegacyAaveFeeCollectModuleSettings
  | UnknownOpenActionModuleSettings

type SimpleCollectOpenActionSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endTimestamp: DateTime
}

type MultirecipientFeeCollectOpenActionSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # The referral fee associated with this publication.
  referralFee: Float!

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endTimestamp: DateTime

  # Recipient of collect fees.
  recipients: [RecipientDataOutput!]!
}

type RecipientDataOutput {
  # Recipient of collect fees.
  recipient: EvmAddress!

  # Split %, should be between 0.01 and 100. Up to 2 decimal points supported. All % should add up to 100
  split: Float!
}

type LegacyFreeCollectModuleSettings {
  contract: NetworkAddress!

  # Follower only
  followerOnly: Boolean!
}

type LegacyFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # Follower only
  followerOnly: Boolean!
}

type LegacyLimitedFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module limit
  collectLimit: String!

  # The collect module amount info
  amount: Amount!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # Follower only
  followerOnly: Boolean!
}

type LegacyLimitedTimedFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module limit
  collectLimit: String!

  # The collect module amount info
  amount: Amount!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # Follower only
  followerOnly: Boolean!

  # The collect module end timestamp
  endTimestamp: DateTime!
}

type LegacyRevertCollectModuleSettings {
  contract: NetworkAddress!
}

type LegacyTimedFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # Follower only
  followerOnly: Boolean!

  # The collect module end timestamp
  endTimestamp: DateTime!
}

type LegacyMultirecipientFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # The referral fee associated with this publication.
  referralFee: Float!

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endTimestamp: DateTime

  # Recipient of collect fees.
  recipients: [RecipientDataOutput!]!
}

type LegacySimpleCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The collect module recipient address
  recipient: EvmAddress!

  # The collect module referral fee
  referralFee: Float!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endTimestamp: DateTime
}

type LegacyERC4626FeeCollectModuleSettings {
  contract: NetworkAddress!

  # The ERC4626 vault address
  vault: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The recipient of the ERC4626 vault shares
  recipient: EvmAddress!

  # The maximum number of collects for this publication. 0 for no limit.
  collectLimit: String

  # The referral fee associated with this publication.
  referralFee: Float!

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. 0 for no expiry.
  endTimestamp: DateTime
}

type LegacyAaveFeeCollectModuleSettings {
  contract: NetworkAddress!

  # The collect module amount info
  amount: Amount!

  # The maximum number of collects for this publication. Omit for no limit.
  collectLimit: String

  # The referral fee associated with this publication.
  referralFee: Float!

  # True if only followers of publisher may collect the post.
  followerOnly: Boolean!

  # The end timestamp after which collecting is impossible. No expiry if missing.
  endTimestamp: DateTime

  # Recipient of collect fees.
  recipient: EvmAddress!
}

type UnknownOpenActionModuleSettings {
  contract: NetworkAddress!

  # The data used to setup the module which you can decode with your known ABI
  openActionModuleReturnData: BlockchainData!
}

union ReferenceModule =
    FollowOnlyReferenceModuleSettings
  | UnknownReferenceModuleSettings
  | DegreesOfSeparationReferenceModuleSettings

type FollowOnlyReferenceModuleSettings {
  contract: NetworkAddress!
}

type UnknownReferenceModuleSettings {
  contract: NetworkAddress!

  # The data used to setup the module which you can decode with your known ABI
  referenceModuleReturnData: BlockchainData!
}

type DegreesOfSeparationReferenceModuleSettings {
  contract: NetworkAddress!

  # Applied to comments
  commentsRestricted: Boolean!

  # Applied to mirrors
  mirrorsRestricted: Boolean!

  # Applied to quotes
  quotesRestricted: Boolean!

  # Degrees of separation
  degreesOfSeparation: Int!
}

type Comment {
  id: PublicationId!
  by: Profile!
  publishedOn: App
  isHidden: Boolean!
  isGated: Boolean!
  momoka: MomokaInfo
  txHash: TxHash!
  createdAt: DateTime!
  stats(request: PublicationStatsInput!): PublicationStats!
  operations: PublicationOperations!
  metadata: PublicationMetadata!
  openActionModules: [OpenActionModule!]
  referenceModule: ReferenceModule
  root: Post!
  commentOn: PrimaryPublication!
  firstComment: Comment!
}

union PrimaryPublication = Post | Comment | Quote

type Quote {
  id: PublicationId!
  by: Profile!
  publishedOn: App
  isHidden: Boolean!
  isGated: Boolean!
  momoka: MomokaInfo
  txHash: TxHash!
  createdAt: DateTime!
  stats(request: PublicationStatsInput!): PublicationStats!
  operations: PublicationOperations!
  metadata: PublicationMetadata!
  openActionModules: [OpenActionModule!]
  referenceModule: ReferenceModule
  commentOn: PrimaryPublication!
  quotedOn: PrimaryPublication!
}

type Mirror {
  id: PublicationId!
  by: Profile!
  publishedOn: App
  isHidden: Boolean!
  isGated: Boolean!
  momoka: MomokaInfo
  txHash: TxHash!
  createdAt: DateTime!
  mirrorOf: MirrorablePublication!
}

union MirrorablePublication = Post | Comment | Quote

input PublicationsRequest {
  limit: LimitScalar
  cursor: Cursor
  where: PublicationsWhere!
  orderBy: PublicationsOrderByType = COMMENT_OF_QUERY_RANKING
}

input PublicationsWhere {
  publicationIds: [PublicationId!]
  from: [ProfileId!]
  publicationTypes: [PublicationType!]
  commentsOf: PublicationCommentOf
  mirrorOf: PublicationId
  quoteOf: PublicationId
  publishedOn: [AppId!]
  withOpenActions: [OpenActionFilter!]
  acted: [OpenActionFilter!]
  metadata: PublicationMetadataFilters
  customFilters: [CustomFiltersType!]
}

enum PublicationType {
  POST
  COMMENT
  QUOTE
  MIRROR
}

input PublicationCommentOf {
  id: PublicationId!
  commentsRankingFilter: CommentRankingFilterType
}

enum CommentRankingFilterType {
  NONE_RELEVANT
  RELEVANT
}

input PublicationMetadataFilters {
  locale: Locale
  contentWarning: PublicationMetadataContentWarningFilter
  mainContentFocus: [PublicationMetadataMainFocusType!]
  tags: PublicationMetadataTagsFilter
}

input PublicationMetadataContentWarningFilter {
  oneOf: [PublicationContentWarningType!]
}

enum PublicationMetadataMainFocusType {
  VIDEO
  IMAGE
  ARTICLE
  TEXT_ONLY
  AUDIO
  LINK
  EMBED
  CHECKING_IN
  EVENT
  MINT
  TRANSACTION
  LIVESTREAM
  SHORT_VIDEO
  THREE_D
  STORY
  SPACES
}

input PublicationMetadataTagsFilter {
  oneOf: [String!]
  all: [String!]
}

enum PublicationsOrderByType {
  TOP_COMMENTED
  TOP_COLLECTED_OPEN_ACTION
  TOP_MIRRORED
  TOP_QUOTED
  COMMENT_OF_QUERY_RANKING
  LATEST
}

input PublicationRequest {
  for: PublicationId
  txHash: TxHash
}

type PaginatedPublicationsTagsResult {
  items: [TagResult!]!
  pageInfo: PaginatedResultInfo!
}

type TagResult {
  tag: String!
  total: Int!
}

input PublicationsTagsRequest {
  limit: LimitScalar
  cursor: Cursor
  where: PublicationsTagsWhere
  orderBy: TagSortCriteriaType = ALPHABETICAL
}

input PublicationsTagsWhere {
  limit: LimitScalar
  cursor: Cursor
  publishedOn: [AppId!]
}

enum TagSortCriteriaType {
  MOST_POPULAR
  ALPHABETICAL
}

input ProfileBookmarksRequest {
  limit: LimitScalar
  cursor: Cursor
  where: ProfileBookmarksWhere
}

input ProfileBookmarksWhere {
  limit: LimitScalar
  cursor: Cursor
  publishedOn: [AppId!]
  metadata: PublicationMetadataFilters
}

type PaginatedWhoReactedResult {
  items: [ProfileReactedResult!]!
  pageInfo: PaginatedResultInfo!
}

type ProfileReactedResult {
  profile: Profile!
  reactions: [ReactedResult!]!
}

type ReactedResult {
  reaction: PublicationReactionType!
  reactedAt: DateTime!
}

input WhoReactedPublicationRequest {
  limit: LimitScalar
  cursor: Cursor
  for: PublicationId!
  where: WhoReactedPublicationWhere
}

input WhoReactedPublicationWhere {
  limit: LimitScalar
  cursor: Cursor
  anyOf: [PublicationReactionType!]
}

type PaginatedExplorePublicationResult {
  items: [ExplorePublication!]!
  pageInfo: PaginatedResultInfo!
}

union ExplorePublication = Post | Quote

input ExplorePublicationRequest {
  limit: LimitScalar
  cursor: Cursor
  where: ExplorePublicationsWhere
  orderBy: ExplorePublicationsOrderByType!
}

input ExplorePublicationsWhere {
  since: UnixTimestamp
  publishedOn: [AppId!]
  publicationTypes: [ExplorePublicationType!]
  customFilters: [CustomFiltersType!]
  metadata: PublicationMetadataFilters
}

# The unix timestamp
scalar UnixTimestamp

enum ExplorePublicationType {
  POST
  COMMENT
  QUOTE
}

enum ExplorePublicationsOrderByType {
  TOP_COMMENTED
  TOP_COLLECTED_OPEN_ACTION
  TOP_MIRRORED
  TOP_QUOTED
  LATEST
  LENS_CURATED
}

type PublicationValidateMetadataResult {
  valid: Boolean!
  reason: String
}

input ValidatePublicationMetadataRequest {
  rawURI: URI
  json: String
}

type PaginatedForYouResult {
  items: [PublicationForYou!]!
  pageInfo: PaginatedResultInfo!
}

union PublicationForYou = Post | Quote

input PublicationForYouRequest {
  limit: LimitScalar
  cursor: Cursor
  for: ProfileId!
}

type PaginatedRevenueFromPublicationsResult {
  items: [PublicationRevenue!]!
  pageInfo: PaginatedResultInfo!
}

type PublicationRevenue {
  publication: AnyPublication!
  revenue: [RevenueAggregate!]!
}

type RevenueAggregate {
  total: Amount!
}

input RevenueFromPublicationsRequest {
  limit: LimitScalar
  cursor: Cursor
  where: RevenueFromPublicationsWhere!
  for: ProfileId!
}

input RevenueFromPublicationsWhere {
  publishedOn: [AppId!]
  anyOf: [OpenActionFilter!]
  fromCollects: Boolean!
  metadata: PublicationMetadataFilters
  publicationTypes: [PublicationType!]
}

input PublicationRevenueRequest {
  for: PublicationId!
}

type PaginatedPublicationPrimaryResult {
  items: [PrimaryPublication!]!
  pageInfo: PaginatedResultInfo!
}

input PublicationSearchRequest {
  limit: LimitScalar
  cursor: Cursor
  where: PublicationSearchWhere!
  query: String!
}

input PublicationSearchWhere {
  publishedOn: [AppId!]
  customFilters: [CustomFiltersType!]
  publicationTypes: [PublicationType!]
}

type ApprovedAllowanceAmountResult {
  currency: EvmAddress!
  moduleName: String!
  moduleContract: NetworkAddress!
  allowance: String!
}

input ApprovedModuleAllowanceAmountRequest {
  currencies: [EvmAddress!] = []
  openActionModules: [OpenActionModuleType!] = []
  unknownOpenActionModules: [EvmAddress!] = []
  followModules: [FollowModuleType!] = []
  unknownFollowModules: [EvmAddress!] = []
  referenceModules: [ReferenceModuleType!] = []
  unknownReferenceModules: [EvmAddress!] = []
}

enum FollowModuleType {
  FeeFollowModule
  RevertFollowModule
  ProfileFollowModule
  UnknownFollowModule
}

enum ReferenceModuleType {
  FollowerOnlyReferenceModule
  DegreesOfSeparationReferenceModule
  UnknownReferenceModule
}

type GenerateModuleCurrencyApprovalResult {
  to: EvmAddress!
  from: EvmAddress!
  data: BlockchainData!
}

input GenerateModuleCurrencyApprovalDataRequest {
  currency: EvmAddress!
  value: String!
  openActionModule: OpenActionModuleType
  unknownOpenActionModule: EvmAddress
  followModule: FollowModuleType
  unknownFollowModule: EvmAddress
  referenceModule: ReferenceModuleType
  unknownReferenceModule: EvmAddress
}

type SupportedModules {
  openActionsModules: [SupportedModule!]!
  followModules: [SupportedModule!]!
  referenceModules: [SupportedModule!]!
}

type SupportedModule {
  moduleName: String!
  contract: NetworkAddress!
  moduleInput: [ModuleInfo!]!
  redeemInput: [ModuleInfo!]!
  returnDataInput: [ModuleInfo!]!
  isTypeSafe: Boolean!
}

type ModuleInfo {
  name: String!
  type: String!
}

input ProfilesRequest {
  limit: LimitScalar
  cursor: Cursor

  # The where clause to use to filter on what you are looking for
  where: ProfilesRequestWhere!
}

input ProfilesRequestWhere {
  # Pass in an array of evm address to get the profile entities they own
  ownedBy: [ProfileId!]

  # Pass in an array of profile ids to get the profile entities
  profileIds: [ProfileId!]

  # Pass in an array of handles to get the profile entities
  handles: [Handle!]

  # Pass the publication id and get a list of the profiles who quoted it
  whoQuotedPublication: PublicationId

  # Pass the publication id and get a list of the profiles who mirrored it
  whoMirroredPublication: PublicationId

  # Pass the publication id and get a list of the profiles who commented on it
  whoCommentedOn: PublicationId
}

input ProfileRequest {
  # The profile you want to fetch
  profileId: [ProfileId!]

  # The handle for profile you want to fetch
  handle: [Handle!]
}

input WhoActedOnPublicationRequest {
  limit: LimitScalar
  cursor: Cursor
  on: PublicationId!
  where: WhoActedOnPublicationWhere
}

input WhoActedOnPublicationWhere {
  anyOf: [OpenActionFilter!]!
}

type ClaimableProfilesResult {
  reserved: [ReservedClaimable!]!
  canMintProfileWithFreeTextHandle: Boolean!
}

type ReservedClaimable {
  id: String!
  withHandle: Handle!
  source: AppId!
  expiry: DateTime!
}

enum ClaimProfileStatusType {
  ALREADY_CLAIMED
  CLAIM_FAILED
  NOT_CLAIMED
}

input ExploreProfilesRequest {
  limit: LimitScalar
  cursor: Cursor

  # Filtering criteria for exploring profiles
  where: ExploreProfilesWhere

  # Order criteria for exploring profiles
  orderBy: ExploreProfileOrderBy!
}

input ExploreProfilesWhere {
  # Filter profiles created since the specified timestamp
  since: UnixTimestamp

  # Array of custom filters for exploring profiles
  customFilters: [CustomFiltersType!] = []
}

# Possible sort criteria for exploring profiles
enum ExploreProfileOrderBy {
  CREATED_ON
  MOST_FOLLOWERS
  LATEST_CREATED
  MOST_POSTS
  MOST_COMMENTS
  MOST_MIRRORS
  MOST_PUBLICATION
  MOST_COLLECTS
}

type InvitedResult {
  invited: EvmAddress!
  profileMinted: Profile
  when: DateTime!
}

input AlreadyInvitedCheckRequest {
  address: EvmAddress!
}

# The paginated profile managers result
type PaginatedProfileManagersResult {
  items: [ProfilesManagedResult!]!
  pageInfo: PaginatedResultInfo!
}

type ProfilesManagedResult {
  address: EvmAddress!
}

input ProfileManagersRequest {
  # The profile ID for which to retrieve managers
  for: ProfileId!
}

input ProfilesManagedRequest {
  # The Ethereum address for which to retrieve managed profiles
  address: EvmAddress!
}

input ProfileRecommendationsRequest {
  # Filter based on a specific profile ID
  for: ProfileId!

  # Disable machine learning recommendations (default: false)
  disableML: Boolean = false

  # Shuffle the recommendations (default: false)
  shuffle: Boolean = false
}

type FollowRevenueResult {
  revenues: [RevenueAggregate!]!
}

input FollowRevenueRequest {
  for: ProfileId!
}

input ProfileSearchRequest {
  limit: LimitScalar
  cursor: Cursor

  # Query for the profile search
  query: String!

  # Filtering criteria for profile search
  where: ProfileSearchWhere
}

input ProfileSearchWhere {
  # Array of custom filters for profile search
  customFilters: [CustomFiltersType!]
}

type AuthChallengeResult {
  id: ChallengeId!

  # The text that needs to be signed
  text: String!
}

# The challenge id
scalar ChallengeId

input ChallengeRequest {
  # The profile ID to initiate a challenge
  profileId: ProfileId!

  # The profile ID to initiate a challenge
  address: EvmAddress!
}

input VerifyRequest {
  # The access token to verify
  accessToken: Jwt!
}

# The jwt token
scalar Jwt

type PaginatedFeedResult {
  items: [FeedItem!]!
  pageInfo: PaginatedResultInfo!
}

type FeedItem {
  id: String!
  root: PrimaryPublication!
  electedMirror: ElectedMirror
  mirrors: [MirrorEvent!]!
  collects: [CollectedEvent!]!
  reactions: [ReactionEvent!]!
  comments: [Comment!]!
  quotes: [Quote!]!
}

type ElectedMirror {
  mirrorId: PublicationId!
  by: Profile!
  timestamp: DateTime!
}

type MirrorEvent {
  by: Profile!
  timestamp: DateTime!
}

type CollectedEvent {
  by: Profile!
  timestamp: DateTime!
}

type ReactionEvent {
  by: Profile!
  reaction: PublicationReactionType!
  timestamp: DateTime!
}

input FeedRequest {
  limit: LimitScalar
  cursor: Cursor
  where: FeedWhere
}

input FeedWhere {
  feedEventItemTypes: [FeedEventItemType!]
  publishedOn: [AppId!]
  metadata: PublicationMetadataFilters!
  for: ProfileId!
}

enum FeedEventItemType {
  POST
  COMMENT
  MIRROR
  QUOTE
  COLLECT_POST
  COLLECT_COMMENT
  REACTION_POST
  REACTION_COMMENT
}

type PaginatedFeedHighlightsResult {
  items: [FeedHighlight!]!
  pageInfo: PaginatedResultInfo!
}

union FeedHighlight = Post | Quote

input FeedHighlightsRequest {
  limit: LimitScalar
  cursor: Cursor
  where: FeedHighlightWhere
}

input FeedHighlightWhere {
  publishedOn: [AppId!]
  metadata: PublicationMetadataFilters!
}

type PaginatedNotificationResult {
  items: [Notification!]!
  pageInfo: PaginatedResultInfo!
}

union Notification =
    ReactionNotification
  | CommentNotification
  | MirrorNotification
  | QuoteNotification
  | ActedNotification
  | FollowNotification
  | MentionNotification
  | FutureProofNotification

type ReactionNotification {
  id: String!
  reactions: [ProfileReactedResult!]!
  publication: PrimaryPublication!
}

type CommentNotification {
  id: String!
  comment: Comment!
}

type MirrorNotification {
  id: String!
  mirrors: [ProfileMirrorResult!]!
  publication: PrimaryPublication!
}

type ProfileMirrorResult {
  id: String!
  mirrorId: PublicationId!
  mirroredAt: DateTime!
  profile: Profile!
}

type QuoteNotification {
  id: String!
  quote: Quote!
}

type ActedNotification {
  id: String!
  actions: [ProfileActedResult!]!
  publication: AnyPublication!
}

type ProfileActedResult {
  id: String!
  profile: Profile!
  action: OpenActionResult!
}

type FollowNotification {
  id: String!
  followers: [Profile!]!
}

type MentionNotification {
  id: String!
  publication: PrimaryPublication!
}

type FutureProofNotification {
  id: String
}

input NotificationRequest {
  limit: LimitScalar
  cursor: Cursor
  where: NotificationWhere
}

input NotificationWhere {
  publishedOn: [AppId!]
  customFilters: [CustomFiltersType!]
  highSignalFilter: Boolean = true
  notificationTypes: [NotificationType!]
}

enum NotificationType {
  MIRRORED
  MENTIONED
  QUOTED
  COMMENTED
  COLLECT_ACTED
  OTHER_ACTED
  FOLLOWED
  REACTED
}

# The paginated User POAP result
type PaginatedPoapResult {
  items: [PoapTokenEvent!]!
  pageInfo: PaginatedResultInfo!
}

# The Poap Token Event
type PoapTokenEvent {
  tokenId: String!

  # Poap Event Details
  event: PoapEvent!

  # Total following count (remember the wallet follows not profile so will be same for every profile they own)
  owner: NetworkAddress!

  # Which network the token is: L1 (eth) or L2 (Gnosis)
  layer: PoapTokenLayerType!

  # Total minted tokens for the event
  supply: PoapTokenSupply!
  created: DateTime!

  # migrated to L1 at
  migrated: DateTime
}

# The POAP Event result
type PoapEvent {
  id: Int!
  fancy_id: String!
  name: String!
  event_url: URL!
  image_url: URL
  country: String
  city: String
  description: String
  year: Int
  start_date: DateTime
  end_date: DateTime
  virtual_event: Boolean
  animation_url: URL
  event_template_id: Int
  private_event: Boolean
}

enum PoapTokenLayerType {
  Layer1
  Layer2
}

# The Poap Token Supply
type PoapTokenSupply {
  # Total minted tokens for the event
  total: Int!

  # Order of the token
  order: Int!
}

input UserPoapsQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  for: ProfileId!
}

input MutualPoapsQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  observer: ProfileId!
  viewing: ProfileId!
}

input PoapHoldersQueryRequest {
  limit: LimitScalar
  cursor: Cursor
  eventId: Float!
}

input FollowersRequest {
  limit: LimitScalar
  cursor: Cursor
  of: ProfileId!
}

input MutualFollowersRequest {
  limit: LimitScalar
  cursor: Cursor
  viewing: ProfileId!
  observer: ProfileId!
}

input FollowingRequest {
  limit: LimitScalar
  cursor: Cursor
  for: ProfileId!
}

input RelRequest {
  secret: String!
  address: EvmAddress!
}

input CurRequest {
  secret: String!
}

input GdmRequest {
  secret: String!
}

input GctRequest {
  secret: String!
}

type PrfResult {
  ss: Boolean!
  dd: Boolean!
}

input PriRequest {
  secret: String!
  hhh: String!
}

input InTotalRequest {
  secret: String!
  address: EvmAddress!
}

type UserSigNonces {
  lensHubOnChainSigNonce: Nonce!
  peripheryOnChainSigNonce: Nonce!
}

# The nonce value
scalar Nonce

type Mutation {
  createNftGallery(request: NftGalleryCreateRequest!): NftGalleryId!
  updateNftGalleryInfo(request: NftGalleryUpdateInfoRequest!): Void
  updateNftGalleryOrder(request: NftGalleryUpdateItemOrderRequest!): Void
  updateNftGalleryItems(request: NftGalleryUpdateItemsRequest!): Void
  deleteNftGallery(request: NftGalleryDeleteRequest!): Void
  nftOwnershipChallenge(request: NftOwnershipChallengeRequest!): NftOwnershipChallengeResult!
  quoteOnMomoka(request: MomokaQuoteRequest!): RelayMomokaResult!
  postOnMomoka(request: MomokaPostRequest!): RelayMomokaResult!
  commentOnMomoka(request: MomokaCommentRequest!): RelayMomokaResult!
  mirrorOnMomoka(request: MomokaMirrorRequest!): RelayMomokaResult!
  broadcastOnMomoka(request: BroadcastRequest!): BroadcastMomokaResult!
  broadcastOnChain(request: BroadcastRequest!): RelayResult!
  createMomokaQuoteTypedData(request: MomokaQuoteRequest!): CreateMomokaQuoteBroadcastItemResult!
  createMomokaPostTypedData(request: MomokaPostRequest!): CreateMomokaPostBroadcastItemResult!
  createMomokaCommentTypedData(
    request: MomokaCommentRequest!
  ): CreateMomokaCommentBroadcastItemResult!
  createMomokaMirrorTypedData(request: MomokaMirrorRequest!): CreateMomokaMirrorBroadcastItemResult!
  hidePublication(request: HidePublicationRequest!): Void!
  addPublicationNotInterested(request: PublicationNotInterestedRequest!): Void!
  undoPublicationNotInterested(request: PublicationNotInterestedRequest!): Void!
  addPublicationBookmark(request: PublicationBookmarkRequest!): Void!
  removePublicationBookmark(request: PublicationBookmarkRequest!): Void!
  addReaction(request: ReactionRequest!): Void!
  removeReaction(request: ReactionRequest!): Void!
  reportPublication(request: ReportPublicationRequest!): Void!
  dismissRecommendedProfiles(request: DismissRecommendedProfilesRequest!): Void!
  quoteOnChain(request: CreateOnChainQuoteRequest!): LensProfileManagerRelayResult!
  postOnChain(request: CreateOnChainPostRequest!): LensProfileManagerRelayResult!
  commentOnChain(request: CreateOnChainCommentRequest!): LensProfileManagerRelayResult!
  mirrorOnChain(request: CreateOnChainMirrorRequest!): LensProfileManagerRelayResult!
  createOnChainQuoteTypedData(
    options: TypedDataOptions
    request: CreateOnChainQuoteRequest!
  ): CreateOnChainQuoteBroadcastItemResult!
  createOnChainPostTypedData(
    options: TypedDataOptions
    request: CreateOnChainPostRequest!
  ): CreateOnChainPostBroadcastItemResult!
  createOnChainCommentTypedData(
    options: TypedDataOptions
    request: CreateOnChainCommentRequest!
  ): CreateOnChainCommentBroadcastItemResult!
  createOnChainMirrorTypedData(
    options: TypedDataOptions
    request: CreateOnChainMirrorRequest!
  ): CreateOnChainMirrorBroadcastItemResult!
  setFollowModule(request: SetFollowModuleRequest!): LensProfileManagerRelayResult!
  actOnOpenAction(request: ActOnOpenActionRequest!): LensProfileManagerRelayResult!
  legacyCollectPublication(
    request: LegacyCollectPublicationRequest!
  ): LensProfileManagerRelayResult!
  createSetFollowModuleTypedData(
    options: TypedDataOptions
    request: SetFollowModuleRequest!
  ): CreateSetFollowModuleBroadcastItemResult!
  createActOnOpenActionTypedData(
    options: TypedDataOptions
    request: ActOnOpenActionRequest!
  ): CreateActOnOpenActionBroadcastItemResult!
  createLegacyCollectPublicationTypedData(
    options: TypedDataOptions
    request: LegacyCollectPublicationRequest!
  ): CreateLegacyCollectPublicationEIP712TypedData!
  addProfileInterests(request: ProfileInterestsRequest!): Void!
  removeProfileInterests(request: ProfileInterestsRequest!): Void!
  claimProfile(request: ClaimProfileRequest!): CreateProfileResult!
  createProfile(request: CreateProfileRequest!): CreateProfileResult!
  inviteProfile(request: InviteRequest!): Void
  block(request: BlockRequest!): LensProfileManagerRelayResult!
  unblock(request: UnblockRequest!): LensProfileManagerRelayResult!
  setProfileMetadata(request: SetProfileMetadataRequest!): LensProfileManagerRelayResult!
  setProfileImageURI(request: SetProfileImageRequest!): LensProfileManagerRelayResult!
  setProfileManager(request: ChangeProfileManagersRequest!): LensProfileManagerRelayResult!
  createSetProfileMetadataTypedData(
    options: TypedDataOptions
    request: SetProfileMetadataRequest!
  ): CreateSetProfileMetadataBroadcastItemResult!
  createSetProfileImageTypedData(
    options: TypedDataOptions
    request: SetProfileImageRequest!
  ): CreateSetProfileImageBroadcastItemResult!
  createChangeProfileManagersTypedData(
    options: TypedDataOptions
    request: ChangeProfileManagersRequest!
  ): CreateChangeProfileManagersBroadcastItemResult!
  createBlockProfileTypedData(
    options: TypedDataOptions
    request: BlockRequest!
  ): CreateBlockProfileBroadcastItemResult!
  createUnblockProfileTypedData(
    options: TypedDataOptions
    request: UnblockRequest!
  ): CreateUnblockProfileBroadcastItemResult!
  authenticate(request: SignedAuthChallenge!): AuthenticationResult!
  refresh(request: RefreshRequest!): AuthenticationResult!
  idKitPhoneVerifyWebhook(
    request: IdKitPhoneVerifyWebhookRequest!
  ): IdKitPhoneVerifyWebhookResultStatusType!
  follow(request: FollowRequest!): LensProfileManagerRelayResult!
  unfollow(request: UnfollowRequest!): LensProfileManagerRelayResult!
  createFollowTypedData(
    options: TypedDataOptions
    request: FollowRequest!
  ): CreateFollowBroadcastItemResult!
  createUnfollowTypedData(
    options: TypedDataOptions
    request: UnfollowRequest!
  ): CreateUnfollowBroadcastItemResult!
  ach(request: AchRequest!): Void
  hel(request: HelRequest!): Void
  gdi(request: GddRequest!): Void
  gci(request: GciRequest!): Void
  gcr(request: GcrRequest!): Void
  dss(request: PrfRequest!): Void
  nni(request: NniRequest!): Void
  nnv(request: NnvRequest!): Void
  in(request: InRequest!): Void
  internalPin(request: InternalPinRequest!): InternalPinResult!
}

input NftGalleryCreateRequest {
  name: NftGalleryName!
  items: [NftInput!]!
}

input NftInput {
  contract: NetworkAddressInput!
  tokenId: TokenId!
}

input NftGalleryUpdateInfoRequest {
  galleryId: NftGalleryId!
  name: NftGalleryName!
}

input NftGalleryUpdateItemOrderRequest {
  galleryId: NftGalleryId!
  updates: [NftUpdateItemOrder!] = []
}

input NftUpdateItemOrder {
  contract: NetworkAddressInput!
  tokenId: TokenId!
  newOrder: Int!
}

input NftGalleryUpdateItemsRequest {
  galleryId: NftGalleryId!
  toAdd: [NftInput!] = []
  toRemove: [NftInput!] = []
}

input NftGalleryDeleteRequest {
  galleryId: NftGalleryId!
}

type NftOwnershipChallengeResult {
  id: String!
  text: String!
}

input NftOwnershipChallengeRequest {
  for: EvmAddress!
  nfts: [NftOwnershipChallenge!]!
}

input NftOwnershipChallenge {
  contract: NetworkAddressInput!
  tokenId: TokenId!
}

union RelayMomokaResult = CreateMomokaPublicationResult | RelayError

type CreateMomokaPublicationResult {
  id: PublicationId!
  proof: MomokaProof!
  momokaId: MomokaId!
}

# The momoke id
scalar MomokaId

type RelayError {
  reason: RelayErrorReasonType!
}

enum RelayErrorReasonType {
  RATE_LIMITED
  FAILED
  EXPIRED
  WRONG_WALLET_SIGNED
  APP_GASLESS_NOT_ALLOWED
}

input MomokaQuoteRequest {
  contentURI: URI!
}

input MomokaPostRequest {
  contentURI: URI!
}

input MomokaCommentRequest {
  commentOn: PublicationId!
  contentURI: URI!
}

input MomokaMirrorRequest {
  mirror: PublicationId!
  from: ProfileId!
}

union BroadcastMomokaResult = CreateMomokaPublicationResult | RelayError

input BroadcastRequest {
  id: BroadcastId!
  signature: Signature!
}

# The broadcast id
scalar BroadcastId

# The signature value
scalar Signature

union RelayResult = RelaySuccess | RelayError

type RelaySuccess {
  txHash: TxHash
  txId: TxId
}

type CreateMomokaQuoteBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateMomokaQuoteEIP712TypedData!
}

type CreateMomokaQuoteEIP712TypedData {
  # The types
  types: CreateMomokaQuoteEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateMomokaQuoteEIP712TypedDataValue!
}

type CreateMomokaQuoteEIP712TypedDataTypes {
  QuoteWithSig: [EIP712TypedDataField!]!
}

# The eip 712 typed data field
type EIP712TypedDataField {
  # The name of the typed data field
  name: String!

  # The type of the typed data field
  type: String!
}

# The eip 712 typed data domain
type EIP712TypedDataDomain {
  # The name of the typed data domain
  name: String!

  # The chainId
  chainId: ChainId!

  # The version
  version: String!

  # The verifying contract
  verifyingContract: EvmAddress!
}

type CreateMomokaQuoteEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateMomokaPostBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateMomokaPostEIP712TypedData!
}

type CreateMomokaPostEIP712TypedData {
  # The types
  types: CreateMomokaPostEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateMomokaPostEIP712TypedDataValue!
}

type CreateMomokaPostEIP712TypedDataTypes {
  PostWithSig: [EIP712TypedDataField!]!
}

type CreateMomokaPostEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateMomokaCommentBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateMomokaCommentEIP712TypedData!
}

type CreateMomokaCommentEIP712TypedData {
  # The types
  types: CreateMomokaCommentEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateMomokaCommentEIP712TypedDataValue!
}

type CreateMomokaCommentEIP712TypedDataTypes {
  CommentWithSig: [EIP712TypedDataField!]!
}

type CreateMomokaCommentEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateMomokaMirrorBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateMomokaMirrorEIP712TypedData!
}

type CreateMomokaMirrorEIP712TypedData {
  # The types
  types: CreateMomokaMirrorEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateMomokaMirrorEIP712TypedDataValue!
}

type CreateMomokaMirrorEIP712TypedDataTypes {
  MirrorWithSig: [EIP712TypedDataField!]!
}

type CreateMomokaMirrorEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

input HidePublicationRequest {
  for: PublicationId!
}

input PublicationNotInterestedRequest {
  on: PublicationId!
}

input PublicationBookmarkRequest {
  on: PublicationId!
}

input ReactionRequest {
  reaction: PublicationReactionType!
  for: PublicationId!
}

input ReportPublicationRequest {
  for: PublicationId!
  reason: ReportingReasonInput!
  additionalComments: String
}

input ReportingReasonInput {
  sensitiveReason: SensitiveReasonInput
  illegalReason: IllegalReasonInput
  fraudReason: FraudReasonInput
  spamReason: SpamReasonInput
}

input SensitiveReasonInput {
  reason: PublicationReportingReason!
  subreason: PublicationReportingSensitiveSubreason!
}

enum PublicationReportingReason {
  SENSITIVE
  ILLEGAL
  FRAUD
  SPAM
}

enum PublicationReportingSensitiveSubreason {
  NSFW
  OFFENSIVE
}

input IllegalReasonInput {
  reason: PublicationReportingReason!
  subreason: PublicationReportingIllegalSubreason!
}

enum PublicationReportingIllegalSubreason {
  ANIMAL_ABUSE
  HUMAN_ABUSE
  VIOLENCE
  THREAT_INDIVIDUAL
  DIRECT_THREAT
}

input FraudReasonInput {
  reason: PublicationReportingReason!
  subreason: PublicationReportingFraudSubreason!
}

enum PublicationReportingFraudSubreason {
  SCAM
  IMPERSONATION
}

input SpamReasonInput {
  reason: PublicationReportingReason!
  subreason: PublicationReportingSpamSubreason!
}

enum PublicationReportingSpamSubreason {
  MISLEADING
  MISUSE_HASHTAGS
  UNRELATED
  REPETITIVE
  FAKE_ENGAGEMENT
  MANIPULATION_ALGO
  LOW_SIGNAL
  SOMETHING_ELSE
}

input DismissRecommendedProfilesRequest {
  for: ProfileId!
}

union LensProfileManagerRelayResult = RelaySuccess | LensProfileManagerRelayError

type LensProfileManagerRelayError {
  reason: LensProfileManagerRelayErrorReasonType!
}

enum LensProfileManagerRelayErrorReasonType {
  RATE_LIMITED
  FAILED
  EXPIRED
  WRONG_WALLET_SIGNED
  APP_GASLESS_NOT_ALLOWED
  REQUIRES_SIGNATURE
}

input CreateOnChainQuoteRequest {
  on: PublicationId!
  contentURI: URI!
  openActionModule: [OpenActionModuleInput!]!
  referenceModule: ReferenceModuleInput
}

input OpenActionModuleInput {
  multirecipientCollectOpenAction: MultirecipientFeeCollectModuleInput
  simpleCollectOpenAction: SimpleCollectOpenActionModuleInput
  unknownOpenAction: UnknownOpenActionModuleInput
}

input MultirecipientFeeCollectModuleInput {
  amount: AmountInput!
  collectLimit: String!
  referralFee: Float = 0
  followerOnly: Boolean!
  endsAt: DateTime
  recipients: [RecipientDataInput!]!
}

input AmountInput {
  # The currency
  currency: NetworkAddressInput!

  # Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal.
  value: String!
}

input RecipientDataInput {
  # Recipient of collect fees.
  recipient: EvmAddress!

  # Split %, should be between 0.01 and 100. Up to 2 decimal points supported. All % should add up to 100
  split: Float!
}

input SimpleCollectOpenActionModuleInput {
  amount: AmountInput!
  referralFee: Float = 0
  recipient: EvmAddress!
  collectLimit: String!
  followerOnly: Boolean!
  endsAt: DateTime
}

input UnknownOpenActionModuleInput {
  address: EvmAddress!
  data: BlockchainData!
}

input ReferenceModuleInput {
  followerOnlyReferenceModule: Boolean
  unknownReferenceModule: UnknownReferenceModuleInput
  degreesOfSeparationReferenceModule: DegreesOfSeparationReferenceModuleInput
}

input UnknownReferenceModuleInput {
  address: EvmAddress!
  data: BlockchainData!
}

input DegreesOfSeparationReferenceModuleInput {
  commentsRestricted: Boolean!
  mirrorsRestricted: Boolean!
  quotesRestricted: Boolean!
  degreesOfSeparation: Int!
}

input CreateOnChainPostRequest {
  contentURI: URI!
  openActionModule: [OpenActionModuleInput!]!
  referenceModule: ReferenceModuleInput
}

input CreateOnChainCommentRequest {
  contentURI: URI!
  commentOn: PublicationId!
  openActionModule: [OpenActionModuleInput!]!
  referenceModule: ReferenceModuleInput
}

input CreateOnChainMirrorRequest {
  on: PublicationId!
}

type CreateOnChainQuoteBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateOnChainQuoteEIP712TypedData!
}

type CreateOnChainQuoteEIP712TypedData {
  # The types
  types: CreateOnChainMirrorEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateOnChainQuoteEIP712TypedDataValue!
}

type CreateOnChainMirrorEIP712TypedDataTypes {
  MirrorWithSig: [EIP712TypedDataField!]!
}

type CreateOnChainQuoteEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

input TypedDataOptions {
  # If you wish to override the nonce for the sig if you want to do some clever stuff in the client
  overrideSigNonce: Nonce!
}

type CreateOnChainPostBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateOnChainPostEIP712TypedData!
}

type CreateOnChainPostEIP712TypedData {
  # The types
  types: CreateOnChainPostEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateOnChainPostEIP712TypedDataValue!
}

type CreateOnChainPostEIP712TypedDataTypes {
  PostWithSig: [EIP712TypedDataField!]!
}

type CreateOnChainPostEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateOnChainCommentBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateOnChainCommentEIP712TypedData!
}

type CreateOnChainCommentEIP712TypedData {
  # The types
  types: CreateOnChainCommentEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateOnChainCommentEIP712TypedDataValue!
}

type CreateOnChainCommentEIP712TypedDataTypes {
  CommentWithSig: [EIP712TypedDataField!]!
}

type CreateOnChainCommentEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateOnChainMirrorBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateOnChainMirrorEIP712TypedData!
}

type CreateOnChainMirrorEIP712TypedData {
  # The types
  types: CreateOnChainMirrorEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateOnChainMirrorEIP712TypedDataValue!
}

type CreateOnChainMirrorEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

input SetFollowModuleRequest {
  followModule: FollowModuleInput!
}

input FollowModuleInput {
  feeFollowModule: FeeFollowModuleInput
  revertFollowModule: Boolean
  freeFollowModule: Boolean
  unknownFollowModule: UnknownFollowModuleInput
}

input FeeFollowModuleInput {
  amount: AmountInput!
  recipient: EvmAddress!
}

input UnknownFollowModuleInput {
  address: EvmAddress!
  data: BlockchainData!
}

input ActOnOpenActionRequest {
  for: PublicationId
  multirecipientCollectOpenAction: Boolean
  simpleCollectOpenAction: Boolean
  unknownOpenAction: UnknownOpenActionActRedeemInput
}

input UnknownOpenActionActRedeemInput {
  address: EvmAddress!
  data: BlockchainData!
}

input LegacyCollectPublicationRequest {
  on: PublicationId!
}

type CreateSetFollowModuleBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateSetFollowModuleEIP712TypedData!
}

type CreateSetFollowModuleEIP712TypedData {
  # The types
  types: CreateSetFollowModuleEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateSetFollowModuleEIP712TypedDataValue!
}

type CreateSetFollowModuleEIP712TypedDataTypes {
  SetFollowModuleWithSig: [EIP712TypedDataField!]!
}

type CreateSetFollowModuleEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateActOnOpenActionBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateActOnOpenActionEIP712TypedData!
}

type CreateActOnOpenActionEIP712TypedData {
  # The types
  types: CreateActOnOpenActionEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateActOnOpenActionEIP712TypedDataValue!
}

type CreateActOnOpenActionEIP712TypedDataTypes {
  ActWithSig: [EIP712TypedDataField!]!
}

type CreateActOnOpenActionEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateLegacyCollectPublicationEIP712TypedData {
  # The types
  types: CreateLegacyCollectPublicationEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateLegacyCollectPublicationEIP712TypedDataValue!
}

type CreateLegacyCollectPublicationEIP712TypedDataTypes {
  ActWithSig: [EIP712TypedDataField!]!
}

type CreateLegacyCollectPublicationEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

input ProfileInterestsRequest {
  interests: String!
}

union CreateProfileResult = RelaySuccess | CreateProfileErrorResult

type CreateProfileErrorResult {
  reason: CreateProfileErrorReasonType!
}

enum CreateProfileErrorReasonType {
  FAILED
  HANDLE_TAKEN
}

input ClaimProfileRequest {
  id: String!
  freeTextHandle: CreateHandle
  followModule: FollowModuleInput
}

# Create handle value
scalar CreateHandle

input CreateProfileRequest {
  handle: CreateHandle!
  profilePictureURI: URI
  followModule: FollowModuleInput
}

input InviteRequest {
  invites: [EvmAddress!]!
  secret: String!
}

input BlockRequest {
  profile: ProfileId!
}

input UnblockRequest {
  profile: ProfileId!
}

input SetProfileMetadataRequest {
  metadataURI: URI!
}

input SetProfileImageRequest {
  imageURI: URI!
}

input ChangeProfileManagersRequest {
  remove: [EvmAddress!]
  add: [EvmAddress!]
  lens: Boolean!
}

type CreateSetProfileMetadataBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateSetProfileMetadataEIP712TypedData!
}

type CreateSetProfileMetadataEIP712TypedData {
  # The types
  types: CreateSetProfileMetadataEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateSetProfileMetadataEIP712TypedDataValue!
}

type CreateSetProfileMetadataEIP712TypedDataTypes {
  SetProfileMetadataURIWithSig: [EIP712TypedDataField!]!
}

type CreateSetProfileMetadataEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateSetProfileImageBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateSetProfileImageEIP712TypedData!
}

type CreateSetProfileImageEIP712TypedData {
  # The types
  types: CreateSetProfileImageEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateSetProfileImageEIP712TypedDataValue!
}

type CreateSetProfileImageEIP712TypedDataTypes {
  SetProfileImageURIWithSig: [EIP712TypedDataField!]!
}

type CreateSetProfileImageEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateChangeProfileManagersBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateChangeProfileManagersEIP712TypedData!
}

type CreateChangeProfileManagersEIP712TypedData {
  # The types
  types: CreateChangeProfileManagersEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateChangeProfileManagersEIP712TypedDataValue!
}

type CreateChangeProfileManagersEIP712TypedDataTypes {
  ChangeDelegatedExecutorsConfigWithSig: [EIP712TypedDataField!]!
}

type CreateChangeProfileManagersEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateBlockProfileBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateBlockProfileEIP712TypedData!
}

type CreateBlockProfileEIP712TypedData {
  # The types
  types: CreateBlockProfileEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateBlockProfileEIP712TypedDataValue!
}

type CreateBlockProfileEIP712TypedDataTypes {
  SetBlockStatusWithSig: [EIP712TypedDataField!]!
}

type CreateBlockProfileEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

type CreateUnblockProfileBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateUnblockProfileEIP712TypedData!
}

type CreateUnblockProfileEIP712TypedData {
  # The types
  types: CreateUnblockProfileEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateUnblockProfileEIP712TypedDataValue!
}

type CreateUnblockProfileEIP712TypedDataTypes {
  SetBlockStatusWithSig: [EIP712TypedDataField!]!
}

type CreateUnblockProfileEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

# The authentication result
type AuthenticationResult {
  # The access token
  accessToken: Jwt!

  # The refresh token
  refreshToken: Jwt!
}

# The signed auth challenge
input SignedAuthChallenge {
  id: ChallengeId!

  # The signature
  signature: Signature!
}

# The refresh request
input RefreshRequest {
  # The refresh token
  refreshToken: Jwt!
}

enum IdKitPhoneVerifyWebhookResultStatusType {
  SUCCESS
  ALREADY_VERIFIED
}

input IdKitPhoneVerifyWebhookRequest {
  sharedSecret: String!
  worldcoin: WorldcoinPhoneVerifyWebhookRequest
}

input WorldcoinPhoneVerifyWebhookRequest {
  nullifierHash: String!
  signalType: WorldcoinPhoneVerifyType!
  signal: EvmAddress!
}

enum WorldcoinPhoneVerifyType {
  PHONE
  ORB
}

input FollowRequest {
  follow: [Follow!]!
}

input Follow {
  profile: ProfileId!
  followModule: FollowModuleRedeemInput
}

input FollowModuleRedeemInput {
  feeFollowModule: FeeFollowModuleRedeemInput
  profileFollowModule: ProfileFollowModuleRedeemInput
  unknownFollowModule: UnknownFollowModuleRedeemInput
}

input FeeFollowModuleRedeemInput {
  amount: AmountInput!
}

input ProfileFollowModuleRedeemInput {
  profileId: ProfileId!
}

input UnknownFollowModuleRedeemInput {
  data: BlockchainData!
}

input UnfollowRequest {
  profile: ProfileId!
}

type CreateFollowBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateFollowEIP712TypedData!
}

# The create follow eip 712 typed data
type CreateFollowEIP712TypedData {
  # The types
  types: CreateFollowEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateFollowEIP712TypedDataValue!
}

# The create follow eip 712 typed data types
type CreateFollowEIP712TypedDataTypes {
  FollowWithSig: [EIP712TypedDataField!]!
}

# The create follow eip 712 typed data value
type CreateFollowEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  profileIds: [ProfileId!]!
  datas: [BlockchainData!]!
}

type CreateUnfollowBroadcastItemResult {
  # This broadcast item ID
  id: BroadcastId!

  # The date the broadcast item expiries
  expiresAt: DateTime!

  # The typed data
  typedData: CreateUnfollowEIP712TypedData!
}

type CreateUnfollowEIP712TypedData {
  # The types
  types: CreateUnfollowEIP712TypedDataTypes!

  # The typed data domain
  domain: EIP712TypedDataDomain!

  # The values
  value: CreateUnfollowEIP712TypedDataValue!
}

type CreateUnfollowEIP712TypedDataTypes {
  UnfollowWithSig: [EIP712TypedDataField!]!
}

type CreateUnfollowEIP712TypedDataValue {
  nonce: Nonce!
  deadline: UnixTimestamp!
  fillIn: String!
}

input AchRequest {
  secret: String!
  address: EvmAddress!
  handle: CreateHandle!
  freeTextHandle: Boolean!
  overrideTradeMark: Boolean!
  overrideAlreadyClaimed: Boolean!
}

input HelRequest {
  secret: String!
  handle: Handle!
  remove: Boolean!
}

input GddRequest {
  secret: String!
  domain: URL!
}

input GciRequest {
  secret: String!
  hhh: String!
  ttt: String!
}

input GcrRequest {
  secret: String!
  hhh: String!
  ttt: String!
}

input PrfRequest {
  secret: String!
  hhh: String!
  ss: Boolean!
  dd: Boolean!
}

input NniRequest {
  secret: String!
  n: [Nfi!]!
}

input Nfi {
  c: EvmAddress!
  i: ChainId!
}

input NnvRequest {
  secret: String!
  n: [Nfi!]!
}

input InRequest {
  secret: String!
  address: EvmAddress!
  numInvites: Int!
}

type InternalPinResult {
  referenceItem: URL!
  ipfs: IpfsCid!
}

# IpfsCid scalar type
scalar IpfsCid

input InternalPinRequest {
  secret: String!
  items: [URL!]!
}

type Subscription {
  newMomokaTransaction: MomokaTransaction!
  newPublicationStats(request: PublicationStatsSubscriptionRequest!): PublicationStats!
  newNotification(request: NotificationSubscriptionRequest!): Notification!
}

input PublicationStatsSubscriptionRequest {
  for: PublicationId!
}

input NotificationSubscriptionRequest {
  for: ProfileId!
}
